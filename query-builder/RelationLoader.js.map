{"version":3,"sources":["../../src/query-builder/RelationLoader.ts"],"names":[],"mappings":";;;AAOA,qDAAoD;AAEpD;;;GAGG;AACH;IACI,4EAA4E;IAC5E,cAAc;IACd,4EAA4E;IAE5E,wBAAoB,UAAsB;QAAtB,eAAU,GAAV,UAAU,CAAY;IAAG,CAAC;IAE9C,4EAA4E;IAC5E,iBAAiB;IACjB,4EAA4E;IAE5E;;OAEG;IACH,6BAAI,GAAJ,UACI,QAA0B,EAC1B,gBAAiD,EACjD,WAAyB,EACzB,YAAsC;QAEtC,iDAAiD;QACjD,IAAI,WAAW,IAAI,WAAW,CAAC,UAAU;YAAE,WAAW,GAAG,SAAS,CAAC,CAAC,gCAAgC;QACpG,IAAI,QAAQ,CAAC,WAAW,IAAI,QAAQ,CAAC,eAAe,EAAE;YAClD,OAAO,IAAI,CAAC,4BAA4B,CACpC,QAAQ,EACR,gBAAgB,EAChB,WAAW,EACX,YAAY,CACf,CAAC;SACL;aAAM,IAAI,QAAQ,CAAC,WAAW,IAAI,QAAQ,CAAC,kBAAkB,EAAE;YAC5D,OAAO,IAAI,CAAC,+BAA+B,CACvC,QAAQ,EACR,gBAAgB,EAChB,WAAW,EACX,YAAY,CACf,CAAC;SACL;aAAM,IAAI,QAAQ,CAAC,iBAAiB,EAAE;YACnC,OAAO,IAAI,CAAC,mBAAmB,CAC3B,QAAQ,EACR,gBAAgB,EAChB,WAAW,EACX,YAAY,CACf,CAAC;SACL;aAAM;YACH,yBAAyB;YACzB,OAAO,IAAI,CAAC,sBAAsB,CAC9B,QAAQ,EACR,gBAAgB,EAChB,WAAW,EACX,YAAY,CACf,CAAC;SACL;IACL,CAAC;IAED;;;;;;;OAOG;IACH,qDAA4B,GAA5B,UACI,QAA0B,EAC1B,gBAAiD,EACjD,WAAyB,EACzB,YAAsC;QAJ1C,iBAuGC;QAjGG,IAAM,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAC,gBAAgB,CAAC;YAC5C,CAAC,CAAC,gBAAgB;YAClB,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC;QAEzB,IAAM,EAAE,GAAG,YAAY;YACnB,CAAC,CAAC,YAAY;YACd,CAAC,CAAC,IAAI,CAAC,UAAU;iBACV,kBAAkB,CAAC,WAAW,CAAC;iBAC/B,MAAM,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC,WAAW;iBACzC,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,QAAQ,CAAC,YAAY,CAAC,CAAC,CAAC,qBAAqB;QAE5E,IAAM,SAAS,GAAG,EAAE,CAAC,aAAa,CAAC,SAAU,CAAC,IAAI,CAAC;QACnD,IAAM,OAAO,GAAG,QAAQ,CAAC,cAAc,CAAC,cAAc,CAAC;QACvD,IAAM,WAAW,GAAG,QAAQ,CAAC,QAAQ;YACjC,CAAC,CAAC,QAAQ,CAAC,WAAW;YACtB,CAAC,CAAC,QAAQ,CAAC,eAAgB,CAAC,WAAW,CAAC;QAC5C,IAAM,aAAa,GACf,QAAQ,CAAC,cAAc,CAAC,IAAI;YAC5B,CAAC,QAAQ,CAAC,cAAc,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;QAC7D,IAAM,UAAU,GAAG,WAAW;aACzB,GAAG,CAAC,UAAA,UAAU;YACX,OAAU,aAAa,SACnB,UAAU,CAAC,YAAY,WACrB,SAAS,SAAI,UAAU,CAAC,gBAAiB,CAAC,YAAc,CAAC;QACnE,CAAC,CAAC;aACD,IAAI,CAAC,OAAO,CAAC,CAAC;QAEnB,EAAE,CAAC,SAAS,CACR,QAAQ,CAAC,cAAc,CAAC,MAAkB,EAC1C,aAAa,EACb,UAAU,CACb,CAAC;QAEF,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;YACtB,IAAM,MAAM,GAAG,QAAQ,CAAC,GAAG,CAAC,UAAA,MAAM;gBAC9B,OAAA,OAAO,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,MAAM,CAAC;YAAjC,CAAiC,CACpC,CAAC;YACF,IAAM,aAAa,GAAG,MAAM,CAAC,KAAK,CAC9B,UAAA,KAAK,IAAI,OAAA,OAAO,KAAK,KAAK,QAAQ,EAAzB,CAAyB,CACrC,CAAC;YAEF,IAAM,cAAc,GAAG,yBAAW,CAAC,8BAA8B,CAC7D,IAAI,CAAC,UAAU,CAAC,MAAM,EACnB,aAAa,SAAI,OAAO,CAAC,CAAC,CAAC,CAAC,YAAc,EAC7C,MAAM,CACT,CAAC;YACF,IAAI,aAAa,EAAE;gBACf,EAAE,CAAC,KAAK,CACD,cAAc,CAAC,KAAK,aAAQ,cAAc,CAAC,MAAM,CAAC,IAAI,CACrD,IAAI,CACP,MAAG,CACP,CAAC;aACL;iBAAM;gBACH,gFAAgF;gBAChF,qHAAqH;gBACrH,0EAA0E;gBAC1E,IAAM,aAAa,GAAG,yBAAW,CAAC,gBAAgB,CAC9C,IAAI,CAAC,UAAU,CAAC,MAAM,EACtB,aAAa,EACb,OAAO,CAAC,CAAC,CAAC,CAAC,YAAY,CAC1B,CAAC;gBACF,EAAE,CAAC,KAAK,CAAI,cAAc,CAAC,KAAK,iBAAY,aAAa,MAAG,CAAC,CAAC;gBAC9D,EAAE,CAAC,YAAY,CAAC,aAAa,EAAE,cAAc,CAAC,MAAM,CAAC,CAAC;aACzD;SACJ;aAAM;YACH,IAAM,SAAS,GAAG,QAAQ;iBACrB,GAAG,CAAC,UAAC,MAAM,EAAE,WAAW;gBACrB,OAAO,OAAO;qBACT,GAAG,CAAC,UAAC,MAAM,EAAE,WAAW;oBACrB,gFAAgF;oBAChF,kFAAkF;oBAClF,IAAM,SAAS,GAAG,yBAAW,CAAC,gBAAgB,CAC1C,KAAI,CAAC,UAAU,CAAC,MAAM,EACtB,aAAa,EACb,SAAS,GAAG,WAAW,GAAG,GAAG,GAAG,WAAW,CAC9C,CAAC;oBACF,EAAE,CAAC,YAAY,CACX,SAAS,EACT,MAAM,CAAC,cAAc,CAAC,MAAM,CAAC,CAChC,CAAC;oBACF,OAAO,CACH,aAAa;wBACb,GAAG;wBACH,MAAM,CAAC,YAAY;wBACnB,MAAM;wBACN,SAAS,CACZ,CAAC;gBACN,CAAC,CAAC;qBACD,IAAI,CAAC,OAAO,CAAC,CAAC;YACvB,CAAC,CAAC;iBACD,GAAG,CAAC,UAAA,SAAS,IAAI,OAAA,GAAG,GAAG,SAAS,GAAG,GAAG,EAArB,CAAqB,CAAC;iBACvC,IAAI,CAAC,MAAM,CAAC,CAAC;YAClB,EAAE,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;SACvB;QAED,OAAO,EAAE,CAAC,OAAO,EAAE,CAAC;QACpB,2CAA2C;IAC/C,CAAC;IAED;;;;;;OAMG;IACH,wDAA+B,GAA/B,UACI,QAA0B,EAC1B,gBAAiD,EACjD,WAAyB,EACzB,YAAsC;QAJ1C,iBAmFC;QA7EG,IAAM,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAC,gBAAgB,CAAC;YAC5C,CAAC,CAAC,gBAAgB;YAClB,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC;QACzB,IAAM,OAAO,GAAG,QAAQ,CAAC,eAAgB,CAAC,WAAW,CAAC;QAEtD,IAAM,EAAE,GAAG,YAAY;YACnB,CAAC,CAAC,YAAY;YACd,CAAC,CAAC,IAAI,CAAC,UAAU;iBACV,kBAAkB,CAAC,WAAW,CAAC;iBAC/B,MAAM,CAAC,QAAQ,CAAC,YAAY,CAAC;iBAC7B,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,QAAQ,CAAC,YAAY,CAAC,CAAC;QAEtD,IAAM,SAAS,GAAG,EAAE,CAAC,aAAa,CAAC,SAAU,CAAC,IAAI,CAAC;QAEnD,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;YACtB,IAAM,MAAM,GAAG,QAAQ,CAAC,GAAG,CAAC,UAAA,MAAM;gBAC9B,OAAA,OAAO,CAAC,CAAC,CAAC,CAAC,gBAAiB,CAAC,cAAc,CAAC,MAAM,CAAC;YAAnD,CAAmD,CACtD,CAAC;YACF,IAAM,aAAa,GAAG,MAAM,CAAC,KAAK,CAC9B,UAAA,KAAK,IAAI,OAAA,OAAO,KAAK,KAAK,QAAQ,EAAzB,CAAyB,CACrC,CAAC;YAEF,IAAM,cAAc,GAAG,yBAAW,CAAC,8BAA8B,CAC7D,IAAI,CAAC,UAAU,CAAC,MAAM,EACnB,SAAS,SAAI,OAAO,CAAC,CAAC,CAAC,CAAC,YAAc,EACzC,MAAM,CACT,CAAC;YACF,IAAI,aAAa,EAAE;gBACf,EAAE,CAAC,KAAK,CACD,cAAc,CAAC,KAAK,aAAQ,cAAc,CAAC,MAAM,CAAC,IAAI,CACrD,IAAI,CACP,MAAG,CACP,CAAC;aACL;iBAAM;gBACH,gFAAgF;gBAChF,6GAA6G;gBAC7G,sEAAsE;gBACtE,IAAM,aAAa,GAAG,yBAAW,CAAC,gBAAgB,CAC9C,IAAI,CAAC,UAAU,CAAC,MAAM,EACtB,SAAS,EACT,OAAO,CAAC,CAAC,CAAC,CAAC,YAAY,CAC1B,CAAC;gBACF,EAAE,CAAC,KAAK,CAAI,cAAc,CAAC,KAAK,iBAAY,aAAa,MAAG,CAAC,CAAC;gBAC9D,EAAE,CAAC,YAAY,CAAC,aAAa,EAAE,cAAc,CAAC,MAAM,CAAC,CAAC;aACzD;SACJ;aAAM;YACH,IAAM,SAAS,GAAG,QAAQ;iBACrB,GAAG,CAAC,UAAC,MAAM,EAAE,WAAW;gBACrB,OAAO,OAAO;qBACT,GAAG,CAAC,UAAC,MAAM,EAAE,WAAW;oBACrB,gFAAgF;oBAChF,IAAM,SAAS,GAAG,yBAAW,CAAC,gBAAgB,CAC1C,KAAI,CAAC,UAAU,CAAC,MAAM,EACtB,SAAS,EACT,SAAS,GAAG,WAAW,GAAG,GAAG,GAAG,WAAW,CAC9C,CAAC;oBACF,8EAA8E;oBAC9E,EAAE,CAAC,YAAY,CACX,SAAS,EACT,MAAM,CAAC,gBAAiB,CAAC,cAAc,CAAC,MAAM,CAAC,CAClD,CAAC;oBACF,OAAO,CACH,SAAS;wBACT,GAAG;wBACH,MAAM,CAAC,YAAY;wBACnB,MAAM;wBACN,SAAS,CACZ,CAAC;gBACN,CAAC,CAAC;qBACD,IAAI,CAAC,OAAO,CAAC,CAAC;YACvB,CAAC,CAAC;iBACD,GAAG,CAAC,UAAA,SAAS,IAAI,OAAA,GAAG,GAAG,SAAS,GAAG,GAAG,EAArB,CAAqB,CAAC;iBACvC,IAAI,CAAC,MAAM,CAAC,CAAC;YAClB,EAAE,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;SACvB;QACD,OAAO,EAAE,CAAC,OAAO,EAAE,CAAC;QACpB,iFAAiF;IACrF,CAAC;IAED;;;;;;;;OAQG;IACH,4CAAmB,GAAnB,UACI,QAA0B,EAC1B,gBAAiD,EACjD,WAAyB,EACzB,YAAsC;QAJ1C,iBAqEC;QA/DG,IAAM,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAC,gBAAgB,CAAC;YAC5C,CAAC,CAAC,gBAAgB;YAClB,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC;QAEzB,IAAM,EAAE,GAAG,YAAY;YACnB,CAAC,CAAC,YAAY;YACd,CAAC,CAAC,IAAI,CAAC,UAAU;iBACV,kBAAkB,CAAC,WAAW,CAAC;iBAC/B,MAAM,CAAC,QAAQ,CAAC,YAAY,CAAC;iBAC7B,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,QAAQ,CAAC,YAAY,CAAC,CAAC;QAEtD,IAAM,SAAS,GAAG,EAAE,CAAC,aAAa,CAAC,SAAU,CAAC,IAAI,CAAC;QACnD,IAAM,SAAS,GAAG,QAAQ,CAAC,sBAAuB,CAAC,SAAS,CAAC;QAE7D,IAAM,UAAU,GAAkB,EAAE,CAAC;QACrC,IAAM,oBAAoB,GAAa,EAAE,CAAC;QAC1C,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,UAAA,UAAU;YACnC,IAAM,MAAM,GAAG,QAAQ,CAAC,GAAG,CAAC,UAAA,MAAM;gBAC9B,OAAA,UAAU,CAAC,gBAAiB,CAAC,cAAc,CAAC,MAAM,CAAC;YAAnD,CAAmD,CACtD,CAAC;YACF,IAAM,aAAa,GAAG,MAAM,CAAC,KAAK,CAC9B,UAAA,KAAK,IAAI,OAAA,OAAO,KAAK,KAAK,QAAQ,EAAzB,CAAyB,CACrC,CAAC;YAEF,IAAM,cAAc,GAAG,yBAAW,CAAC,8BAA8B,CAC7D,KAAI,CAAC,UAAU,CAAC,MAAM,EACnB,SAAS,SAAI,UAAU,CAAC,YAAc,EACzC,MAAM,CACT,CAAC;YACF,IAAI,aAAa,EAAE;gBACf,oBAAoB,CAAC,IAAI,CAClB,cAAc,CAAC,KAAK,aAAQ,cAAc,CAAC,MAAM,CAAC,IAAI,CACrD,IAAI,CACP,MAAG,CACP,CAAC;aACL;iBAAM;gBACH,UAAU,CAAC,UAAU,CAAC,YAAY,CAAC,GAAG,cAAc,CAAC,MAAM,CAAC;gBAC5D,oBAAoB,CAAC,IAAI,CAClB,cAAc,CAAC,KAAK,iBAAY,UAAU,CAAC,YAAY,MAAG,CAChE,CAAC;aACL;QACL,CAAC,CAAC,CAAC;QAEH,IAAM,2BAA2B,GAAG,QAAQ,CAAC,kBAAkB,CAAC,GAAG,CAC/D,UAAA,iBAAiB;YACb,OAAU,SAAS,SACf,iBAAiB,CAAC,YAAY,SAC9B,SAAS,SACT,iBAAiB,CAAC,gBAAiB,CAAC,YACtC,CAAC;QACP,CAAC,CACJ,CAAC;QAEF,OAAO,EAAE;aACJ,SAAS,CACN,SAAS,EACT,SAAS,EACT,iBAAI,oBAAoB,EAAK,2BAA2B,EAAE,IAAI,CAC1D,OAAO,CACV,CACJ;aACA,aAAa,CAAC,UAAU,CAAC;aACzB,OAAO,EAAE,CAAC;IACnB,CAAC;IAED;;;;;;;;OAQG;IACH,+CAAsB,GAAtB,UACI,QAA0B,EAC1B,gBAAiD,EACjD,WAAyB,EACzB,YAAsC;QAJ1C,iBAkEC;QA5DG,IAAM,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAC,gBAAgB,CAAC;YAC5C,CAAC,CAAC,gBAAgB;YAClB,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC;QAEzB,IAAM,EAAE,GAAG,YAAY;YACnB,CAAC,CAAC,YAAY;YACd,CAAC,CAAC,IAAI,CAAC,UAAU;iBACV,kBAAkB,CAAC,WAAW,CAAC;iBAC/B,MAAM,CAAC,QAAQ,CAAC,YAAY,CAAC;iBAC7B,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,QAAQ,CAAC,YAAY,CAAC,CAAC;QAEtD,IAAM,SAAS,GAAG,EAAE,CAAC,aAAa,CAAC,SAAU,CAAC,IAAI,CAAC;QACnD,IAAM,SAAS,GAAG,QAAQ,CAAC,sBAAuB,CAAC,SAAS,CAAC;QAC7D,IAAM,oBAAoB,GAAG,QAAQ,CAAC,eAAgB,CAAC,WAAW,CAAC,GAAG,CAClE,UAAA,UAAU;YACN,OAAU,SAAS,SACf,UAAU,CAAC,YAAY,WACrB,SAAS,SAAI,UAAU,CAAC,gBAAiB,CAAC,YAAc,CAAC;QACnE,CAAC,CACJ,CAAC;QAEF,IAAM,UAAU,GAAkB,EAAE,CAAC;QACrC,IAAM,2BAA2B,GAAa,EAAE,CAAC;QACjD,QAAQ,CAAC,eAAgB,CAAC,kBAAkB,CAAC,OAAO,CAAC,UAAA,MAAM;YACvD,IAAM,MAAM,GAAG,QAAQ,CAAC,GAAG,CAAC,UAAA,MAAM;gBAC9B,OAAA,MAAM,CAAC,gBAAiB,CAAC,cAAc,CAAC,MAAM,CAAC;YAA/C,CAA+C,CAClD,CAAC;YACF,IAAM,aAAa,GAAG,MAAM,CAAC,KAAK,CAC9B,UAAA,KAAK,IAAI,OAAA,OAAO,KAAK,KAAK,QAAQ,EAAzB,CAAyB,CACrC,CAAC;YAEF,IAAM,cAAc,GAAG,yBAAW,CAAC,8BAA8B,CAC7D,KAAI,CAAC,UAAU,CAAC,MAAM,EACnB,SAAS,SAAI,MAAM,CAAC,YAAc,EACrC,MAAM,CACT,CAAC;YACF,IAAI,aAAa,EAAE;gBACf,oBAAoB,CAAC,IAAI,CAClB,cAAc,CAAC,KAAK,aAAQ,cAAc,CAAC,MAAM,CAAC,IAAI,CACrD,IAAI,CACP,MAAG,CACP,CAAC;aACL;iBAAM;gBACH,UAAU,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,cAAc,CAAC,MAAM,CAAC;gBACxD,oBAAoB,CAAC,IAAI,CAClB,cAAc,CAAC,KAAK,iBAAY,MAAM,CAAC,YAAY,MAAG,CAC5D,CAAC;aACL;QACL,CAAC,CAAC,CAAC;QAEH,OAAO,EAAE;aACJ,SAAS,CACN,SAAS,EACT,SAAS,EACT,iBAAI,oBAAoB,EAAK,2BAA2B,EAAE,IAAI,CAC1D,OAAO,CACV,CACJ;aACA,aAAa,CAAC,UAAU,CAAC;aACzB,OAAO,EAAE,CAAC;IACnB,CAAC;IAED;;;OAGG;IACH,uCAAc,GAAd,UACI,QAA0B,EAC1B,MAAqB,EACrB,WAAyB,EACzB,YAAsC;QAEtC,IAAM,cAAc,GAAG,IAAI,CAAC;QAC5B,IAAM,SAAS,GAAG,IAAI,GAAG,QAAQ,CAAC,YAAY,GAAG,IAAI,CAAC,CAAC,4DAA4D;QACnH,IAAM,YAAY,GAAG,YAAY,GAAG,QAAQ,CAAC,YAAY,GAAG,IAAI,CAAC,CAAC,gEAAgE;QAClI,IAAM,YAAY,GAAG,QAAQ,GAAG,QAAQ,CAAC,YAAY,GAAG,IAAI,CAAC,CAAC,kGAAkG;QAEhK,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,QAAQ,CAAC,YAAY,EAAE;YACjD,GAAG,EAAE;gBAAA,iBAwBJ;gBAvBG,IACI,IAAI,CAAC,YAAY,CAAC,KAAK,IAAI;oBAC3B,IAAI,CAAC,SAAS,CAAC,KAAK,SAAS;oBAE7B,2DAA2D;oBAC3D,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;gBAE5C,IAAI,IAAI,CAAC,YAAY,CAAC;oBAClB,2EAA2E;oBAC3E,OAAO,IAAI,CAAC,YAAY,CAAC,CAAC;gBAE9B,0FAA0F;gBAC1F,IAAI,CAAC,YAAY,CAAC,GAAG,cAAc;qBAC9B,IAAI,CAAC,QAAQ,EAAE,IAAI,EAAE,WAAW,EAAE,YAAY,CAAC;qBAC/C,IAAI,CAAC,UAAA,MAAM;oBACR,IAAI,QAAQ,CAAC,UAAU,IAAI,QAAQ,CAAC,WAAW;wBAC3C,MAAM,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;oBACvB,KAAI,CAAC,SAAS,CAAC,GAAG,MAAM,CAAC;oBACzB,KAAI,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC;oBAC1B,OAAO,KAAI,CAAC,YAAY,CAAC,CAAC;oBAC1B,OAAO,KAAI,CAAC,SAAS,CAAC,CAAC;gBAC3B,CAAC,CAAC,CAAC;gBACP,OAAO,IAAI,CAAC,YAAY,CAAC,CAAC;YAC9B,CAAC;YACD,GAAG,EAAE,UAAS,KAAyB;gBAAlC,iBAYJ;gBAXG,IAAI,KAAK,YAAY,OAAO,EAAE;oBAC1B,4EAA4E;oBAC5E,KAAK,CAAC,IAAI,CAAC,UAAA,MAAM;wBACb,KAAI,CAAC,SAAS,CAAC,GAAG,MAAM,CAAC;wBACzB,KAAI,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC;oBAC9B,CAAC,CAAC,CAAC;iBACN;qBAAM;oBACH,gEAAgE;oBAChE,IAAI,CAAC,SAAS,CAAC,GAAG,KAAK,CAAC;oBACxB,IAAI,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC;iBAC7B;YACL,CAAC;YACD,YAAY,EAAE,IAAI;SACrB,CAAC,CAAC;IACP,CAAC;IACL,qBAAC;AAAD,CAzdA,AAydC,IAAA;AAzdY,wCAAc","file":"RelationLoader.js","sourcesContent":["import {\n    Connection,\n    ObjectLiteral,\n    QueryRunner,\n    SelectQueryBuilder\n} from \"../\";\nimport { RelationMetadata } from \"../metadata/RelationMetadata\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n\n/**\n * Wraps entities and creates getters/setters for their relations\n * to be able to lazily load relations when accessing these relations.\n */\nexport class RelationLoader {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private connection: Connection) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Loads relation data for the given entity and its relation.\n     */\n    load(\n        relation: RelationMetadata,\n        entityOrEntities: ObjectLiteral | ObjectLiteral[],\n        queryRunner?: QueryRunner,\n        queryBuilder?: SelectQueryBuilder<any>\n    ): Promise<any[]> {\n        // todo: check all places where it uses non array\n        if (queryRunner && queryRunner.isReleased) queryRunner = undefined; // get new one if already closed\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n            return this.loadManyToOneOrOneToOneOwner(\n                relation,\n                entityOrEntities,\n                queryRunner,\n                queryBuilder\n            );\n        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            return this.loadOneToManyOrOneToOneNotOwner(\n                relation,\n                entityOrEntities,\n                queryRunner,\n                queryBuilder\n            );\n        } else if (relation.isManyToManyOwner) {\n            return this.loadManyToManyOwner(\n                relation,\n                entityOrEntities,\n                queryRunner,\n                queryBuilder\n            );\n        } else {\n            // many-to-many non owner\n            return this.loadManyToManyNotOwner(\n                relation,\n                entityOrEntities,\n                queryRunner,\n                queryBuilder\n            );\n        }\n    }\n\n    /**\n     * Loads data for many-to-one and one-to-one owner relations.\n     *\n     * (ow) post.category<=>category.post\n     * loaded: category from post\n     * example: SELECT category.id AS category_id, category.name AS category_name FROM category category\n     *              INNER JOIN post Post ON Post.category=category.id WHERE Post.id=1\n     */\n    loadManyToOneOrOneToOneOwner(\n        relation: RelationMetadata,\n        entityOrEntities: ObjectLiteral | ObjectLiteral[],\n        queryRunner?: QueryRunner,\n        queryBuilder?: SelectQueryBuilder<any>\n    ): Promise<any> {\n        const entities = Array.isArray(entityOrEntities)\n            ? entityOrEntities\n            : [entityOrEntities];\n\n        const qb = queryBuilder\n            ? queryBuilder\n            : this.connection\n                  .createQueryBuilder(queryRunner)\n                  .select(relation.propertyName) // category\n                  .from(relation.type, relation.propertyName); // Category, category\n\n        const mainAlias = qb.expressionMap.mainAlias!.name;\n        const columns = relation.entityMetadata.primaryColumns;\n        const joinColumns = relation.isOwning\n            ? relation.joinColumns\n            : relation.inverseRelation!.joinColumns;\n        const joinAliasName =\n            relation.entityMetadata.name +\n            (relation.entityMetadata.name === mainAlias ? \"_2\" : \"\");\n        const conditions = joinColumns\n            .map(joinColumn => {\n                return `${joinAliasName}.${\n                    joinColumn.propertyName\n                } = ${mainAlias}.${joinColumn.referencedColumn!.propertyName}`;\n            })\n            .join(\" AND \");\n\n        qb.innerJoin(\n            relation.entityMetadata.target as Function,\n            joinAliasName,\n            conditions\n        );\n\n        if (columns.length === 1) {\n            const values = entities.map(entity =>\n                columns[0].getEntityValue(entity)\n            );\n            const areAllNumbers = values.every(\n                value => typeof value === \"number\"\n            );\n\n            const paramAndValues = DriverUtils.buildParamAndValuesForInClause(\n                this.connection.driver,\n                `${joinAliasName}.${columns[0].propertyPath}`,\n                values\n            );\n            if (areAllNumbers) {\n                qb.where(\n                    `${paramAndValues.param} IN (${paramAndValues.values.join(\n                        \", \"\n                    )})`\n                );\n            } else {\n                // Hack Julien (Fix the parameter too long issue we have on oracle (limit is 30)\n                // qb.where(`${joinAliasName}.${columns[0].propertyPath} IN (:...${joinAliasName + \"_\" + columns[0].propertyName})`);\n                // qb.setParameter(joinAliasName + \"_\" + columns[0].propertyName, values);\n                const parameterName = DriverUtils.buildColumnAlias(\n                    this.connection.driver,\n                    joinAliasName,\n                    columns[0].propertyName\n                );\n                qb.where(`${paramAndValues.param} IN (:...${parameterName})`);\n                qb.setParameter(parameterName, paramAndValues.values);\n            }\n        } else {\n            const condition = entities\n                .map((entity, entityIndex) => {\n                    return columns\n                        .map((column, columnIndex) => {\n                            // Hack Julien (Fix the parameter too long issue we have on oracle (limit is 30)\n                            // const paramName = joinAliasName + \"_entity_\" + entityIndex + \"_\" + columnIndex;\n                            const paramName = DriverUtils.buildColumnAlias(\n                                this.connection.driver,\n                                joinAliasName,\n                                \"entity_\" + entityIndex + \"_\" + columnIndex\n                            );\n                            qb.setParameter(\n                                paramName,\n                                column.getEntityValue(entity)\n                            );\n                            return (\n                                joinAliasName +\n                                \".\" +\n                                column.propertyPath +\n                                \" = :\" +\n                                paramName\n                            );\n                        })\n                        .join(\" AND \");\n                })\n                .map(condition => \"(\" + condition + \")\")\n                .join(\" OR \");\n            qb.where(condition);\n        }\n\n        return qb.getMany();\n        // return qb.getOne(); todo: fix all usages\n    }\n\n    /**\n     * Loads data for one-to-many and one-to-one not owner relations.\n     *\n     * SELECT post\n     * FROM post post\n     * WHERE post.[joinColumn.name] = entity[joinColumn.referencedColumn]\n     */\n    loadOneToManyOrOneToOneNotOwner(\n        relation: RelationMetadata,\n        entityOrEntities: ObjectLiteral | ObjectLiteral[],\n        queryRunner?: QueryRunner,\n        queryBuilder?: SelectQueryBuilder<any>\n    ): Promise<any> {\n        const entities = Array.isArray(entityOrEntities)\n            ? entityOrEntities\n            : [entityOrEntities];\n        const columns = relation.inverseRelation!.joinColumns;\n\n        const qb = queryBuilder\n            ? queryBuilder\n            : this.connection\n                  .createQueryBuilder(queryRunner)\n                  .select(relation.propertyName)\n                  .from(relation.type, relation.propertyName);\n\n        const aliasName = qb.expressionMap.mainAlias!.name;\n\n        if (columns.length === 1) {\n            const values = entities.map(entity =>\n                columns[0].referencedColumn!.getEntityValue(entity)\n            );\n            const areAllNumbers = values.every(\n                value => typeof value === \"number\"\n            );\n\n            const paramAndValues = DriverUtils.buildParamAndValuesForInClause(\n                this.connection.driver,\n                `${aliasName}.${columns[0].propertyPath}`,\n                values\n            );\n            if (areAllNumbers) {\n                qb.where(\n                    `${paramAndValues.param} IN (${paramAndValues.values.join(\n                        \", \"\n                    )})`\n                );\n            } else {\n                // Hack Julien (Fix the parameter too long issue we have on oracle (limit is 30)\n                // qb.where(`${aliasName}.${columns[0].propertyPath} IN (:...${aliasName + \"_\" + columns[0].propertyName})`);\n                // qb.setParameter(aliasName + \"_\" + columns[0].propertyName, values);\n                const parameterName = DriverUtils.buildColumnAlias(\n                    this.connection.driver,\n                    aliasName,\n                    columns[0].propertyName\n                );\n                qb.where(`${paramAndValues.param} IN (:...${parameterName})`);\n                qb.setParameter(parameterName, paramAndValues.values);\n            }\n        } else {\n            const condition = entities\n                .map((entity, entityIndex) => {\n                    return columns\n                        .map((column, columnIndex) => {\n                            // Hack Julien (Fix the parameter too long issue we have on oracle (limit is 30)\n                            const paramName = DriverUtils.buildColumnAlias(\n                                this.connection.driver,\n                                aliasName,\n                                \"entity_\" + entityIndex + \"_\" + columnIndex\n                            );\n                            // const paramName = aliasName + \"_entity_\" + entityIndex + \"_\" + columnIndex;\n                            qb.setParameter(\n                                paramName,\n                                column.referencedColumn!.getEntityValue(entity)\n                            );\n                            return (\n                                aliasName +\n                                \".\" +\n                                column.propertyPath +\n                                \" = :\" +\n                                paramName\n                            );\n                        })\n                        .join(\" AND \");\n                })\n                .map(condition => \"(\" + condition + \")\")\n                .join(\" OR \");\n            qb.where(condition);\n        }\n        return qb.getMany();\n        // return relation.isOneToMany ? qb.getMany() : qb.getOne(); todo: fix all usages\n    }\n\n    /**\n     * Loads data for many-to-many owner relations.\n     *\n     * SELECT category\n     * FROM category category\n     * INNER JOIN post_categories post_categories\n     * ON post_categories.postId = :postId\n     * AND post_categories.categoryId = category.id\n     */\n    loadManyToManyOwner(\n        relation: RelationMetadata,\n        entityOrEntities: ObjectLiteral | ObjectLiteral[],\n        queryRunner?: QueryRunner,\n        queryBuilder?: SelectQueryBuilder<any>\n    ): Promise<any> {\n        const entities = Array.isArray(entityOrEntities)\n            ? entityOrEntities\n            : [entityOrEntities];\n\n        const qb = queryBuilder\n            ? queryBuilder\n            : this.connection\n                  .createQueryBuilder(queryRunner)\n                  .select(relation.propertyName)\n                  .from(relation.type, relation.propertyName);\n\n        const mainAlias = qb.expressionMap.mainAlias!.name;\n        const joinAlias = relation.junctionEntityMetadata!.tableName;\n\n        const parameters: ObjectLiteral = {};\n        const joinColumnConditions: string[] = [];\n        relation.joinColumns.forEach(joinColumn => {\n            const values = entities.map(entity =>\n                joinColumn.referencedColumn!.getEntityValue(entity)\n            );\n            const areAllNumbers = values.every(\n                value => typeof value === \"number\"\n            );\n\n            const paramAndValues = DriverUtils.buildParamAndValuesForInClause(\n                this.connection.driver,\n                `${joinAlias}.${joinColumn.propertyName}`,\n                values\n            );\n            if (areAllNumbers) {\n                joinColumnConditions.push(\n                    `${paramAndValues.param} IN (${paramAndValues.values.join(\n                        \", \"\n                    )})`\n                );\n            } else {\n                parameters[joinColumn.propertyName] = paramAndValues.values;\n                joinColumnConditions.push(\n                    `${paramAndValues.param} IN (:...${joinColumn.propertyName})`\n                );\n            }\n        });\n\n        const inverseJoinColumnConditions = relation.inverseJoinColumns.map(\n            inverseJoinColumn => {\n                return `${joinAlias}.${\n                    inverseJoinColumn.propertyName\n                }=${mainAlias}.${\n                    inverseJoinColumn.referencedColumn!.propertyName\n                }`;\n            }\n        );\n\n        return qb\n            .innerJoin(\n                joinAlias,\n                joinAlias,\n                [...joinColumnConditions, ...inverseJoinColumnConditions].join(\n                    \" AND \"\n                )\n            )\n            .setParameters(parameters)\n            .getMany();\n    }\n\n    /**\n     * Loads data for many-to-many not owner relations.\n     *\n     * SELECT post\n     * FROM post post\n     * INNER JOIN post_categories post_categories\n     * ON post_categories.postId = post.id\n     * AND post_categories.categoryId = post_categories.categoryId\n     */\n    loadManyToManyNotOwner(\n        relation: RelationMetadata,\n        entityOrEntities: ObjectLiteral | ObjectLiteral[],\n        queryRunner?: QueryRunner,\n        queryBuilder?: SelectQueryBuilder<any>\n    ): Promise<any> {\n        const entities = Array.isArray(entityOrEntities)\n            ? entityOrEntities\n            : [entityOrEntities];\n\n        const qb = queryBuilder\n            ? queryBuilder\n            : this.connection\n                  .createQueryBuilder(queryRunner)\n                  .select(relation.propertyName)\n                  .from(relation.type, relation.propertyName);\n\n        const mainAlias = qb.expressionMap.mainAlias!.name;\n        const joinAlias = relation.junctionEntityMetadata!.tableName;\n        const joinColumnConditions = relation.inverseRelation!.joinColumns.map(\n            joinColumn => {\n                return `${joinAlias}.${\n                    joinColumn.propertyName\n                } = ${mainAlias}.${joinColumn.referencedColumn!.propertyName}`;\n            }\n        );\n\n        const parameters: ObjectLiteral = {};\n        const inverseJoinColumnConditions: string[] = [];\n        relation.inverseRelation!.inverseJoinColumns.forEach(column => {\n            const values = entities.map(entity =>\n                column.referencedColumn!.getEntityValue(entity)\n            );\n            const areAllNumbers = values.every(\n                value => typeof value === \"number\"\n            );\n\n            const paramAndValues = DriverUtils.buildParamAndValuesForInClause(\n                this.connection.driver,\n                `${joinAlias}.${column.propertyName}`,\n                values\n            );\n            if (areAllNumbers) {\n                joinColumnConditions.push(\n                    `${paramAndValues.param} IN (${paramAndValues.values.join(\n                        \", \"\n                    )})`\n                );\n            } else {\n                parameters[column.propertyName] = paramAndValues.values;\n                joinColumnConditions.push(\n                    `${paramAndValues.param} IN (:...${column.propertyName})`\n                );\n            }\n        });\n\n        return qb\n            .innerJoin(\n                joinAlias,\n                joinAlias,\n                [...joinColumnConditions, ...inverseJoinColumnConditions].join(\n                    \" AND \"\n                )\n            )\n            .setParameters(parameters)\n            .getMany();\n    }\n\n    /**\n     * Wraps given entity and creates getters/setters for its given relation\n     * to be able to lazily load data when accessing this relation.\n     */\n    enableLazyLoad(\n        relation: RelationMetadata,\n        entity: ObjectLiteral,\n        queryRunner?: QueryRunner,\n        queryBuilder?: SelectQueryBuilder<any>\n    ) {\n        const relationLoader = this;\n        const dataIndex = \"__\" + relation.propertyName + \"__\"; // in what property of the entity loaded data will be stored\n        const promiseIndex = \"__promise_\" + relation.propertyName + \"__\"; // in what property of the entity loading promise will be stored\n        const resolveIndex = \"__has_\" + relation.propertyName + \"__\"; // indicates if relation data already was loaded or not, we need this flag if loaded data is empty\n\n        Object.defineProperty(entity, relation.propertyName, {\n            get: function() {\n                if (\n                    this[resolveIndex] === true ||\n                    this[dataIndex] !== undefined\n                )\n                    // if related data already was loaded then simply return it\n                    return Promise.resolve(this[dataIndex]);\n\n                if (this[promiseIndex])\n                    // if related data is loading then return a promise relationLoader loads it\n                    return this[promiseIndex];\n\n                // nothing is loaded yet, load relation data and save it in the model once they are loaded\n                this[promiseIndex] = relationLoader\n                    .load(relation, this, queryRunner, queryBuilder)\n                    .then(result => {\n                        if (relation.isOneToOne || relation.isManyToOne)\n                            result = result[0];\n                        this[dataIndex] = result;\n                        this[resolveIndex] = true;\n                        delete this[promiseIndex];\n                        return this[dataIndex];\n                    });\n                return this[promiseIndex];\n            },\n            set: function(value: any | Promise<any>) {\n                if (value instanceof Promise) {\n                    // if set data is a promise then wait for its resolve and save in the object\n                    value.then(result => {\n                        this[dataIndex] = result;\n                        this[resolveIndex] = true;\n                    });\n                } else {\n                    // if its direct data set (non promise, probably not safe-typed)\n                    this[dataIndex] = value;\n                    this[resolveIndex] = true;\n                }\n            },\n            configurable: true\n        });\n    }\n}\n"],"sourceRoot":".."}