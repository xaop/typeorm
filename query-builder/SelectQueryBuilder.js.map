{"version":3,"sources":["../../src/query-builder/SelectQueryBuilder.ts"],"names":[],"mappings":"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","file":"SelectQueryBuilder.js","sourcesContent":["import { normalizeFindOptions } from \"../find-options/FindOptionsUtils\";\nimport { ObserverExecutor } from \"../observer/ObserverExecutor\";\nimport { QueryBuilderUtils } from \"./QueryBuilderUtils\";\nimport { RawSqlResultsToEntityTransformer } from \"./transformer/RawSqlResultsToEntityTransformer\";\nimport { ObjectLiteral } from \"../common/ObjectLiteral\";\nimport { SqlServerDriver } from \"../driver/sqlserver/SqlServerDriver\";\nimport { PessimisticLockTransactionRequiredError } from \"../error/PessimisticLockTransactionRequiredError\";\nimport { NoVersionOrUpdateDateColumnError } from \"../error/NoVersionOrUpdateDateColumnError\";\nimport { OptimisticLockVersionMismatchError } from \"../error/OptimisticLockVersionMismatchError\";\nimport { OptimisticLockCanNotBeUsedError } from \"../error/OptimisticLockCanNotBeUsedError\";\nimport { JoinAttribute } from \"./JoinAttribute\";\nimport { RelationIdAttribute } from \"./relation-id/RelationIdAttribute\";\nimport { RelationCountAttribute } from \"./relation-count/RelationCountAttribute\";\nimport { RelationIdLoader } from \"./relation-id/RelationIdLoader\";\nimport { RelationIdMetadataToAttributeTransformer } from \"./relation-id/RelationIdMetadataToAttributeTransformer\";\nimport { RelationCountLoader } from \"./relation-count/RelationCountLoader\";\nimport { RelationCountMetadataToAttributeTransformer } from \"./relation-count/RelationCountMetadataToAttributeTransformer\";\nimport { QueryBuilder } from \"./QueryBuilder\";\nimport { ReadStream } from \"../platform/PlatformTools\";\nimport { LockNotSupportedOnGivenDriverError } from \"../error/LockNotSupportedOnGivenDriverError\";\nimport { MysqlDriver } from \"../driver/mysql/MysqlDriver\";\nimport { PostgresDriver } from \"../driver/postgres/PostgresDriver\";\nimport { OracleDriver } from \"../driver/oracle/OracleDriver\";\nimport { SelectQuery } from \"./SelectQuery\";\nimport { EntityMetadata } from \"../metadata/EntityMetadata\";\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\";\nimport { OrderByCondition } from \"../find-options/OrderByCondition\";\nimport { QueryExpressionMap } from \"./QueryExpressionMap\";\nimport { ObjectType } from \"../common/ObjectType\";\nimport { QueryRunner } from \"../query-runner/QueryRunner\";\nimport { WhereExpression } from \"./WhereExpression\";\nimport { Brackets } from \"./Brackets\";\nimport { AbstractSqliteDriver } from \"../driver/sqlite-abstract/AbstractSqliteDriver\";\nimport { QueryResultCacheOptions } from \"../cache/QueryResultCacheOptions\";\nimport { OffsetWithoutLimitNotSupportedError } from \"../error/OffsetWithoutLimitNotSupportedError\";\nimport { BroadcasterResult } from \"../subscriber/BroadcasterResult\";\nimport { SelectQueryBuilderOption } from \"./SelectQueryBuilderOption\";\nimport {\n    FindOptions,\n    FindOptionsOrder,\n    FindOptionsRelation,\n    FindOptionsSelect,\n    FindOptionsWhere,\n    FindExtraOptions\n} from \"../find-options/FindOptions\";\nimport { RelationMetadata } from \"../metadata/RelationMetadata\";\nimport { FindCriteriaNotFoundError } from \"../error/FindCriteriaNotFoundError\";\nimport { FindOperator } from \"../find-options/FindOperator\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\nimport { AuroraDataApiDriver } from \"../driver/aurora-data-api/AuroraDataApiDriver\";\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\";\nimport { Connection } from \"..\";\n\ntype QueryFindOptions<E> = Pick<FindOptions<E>, \"select\"> & // TODO: Think of better name\n    Pick<FindOptions<E>, \"where\"> &\n    Pick<FindOptions<E>, \"order\"> &\n    Pick<FindOptions<E>, \"relations\"> &\n    Pick<FindOptions<E>, \"skip\"> &\n    Pick<FindOptions<E>, \"take\"> &\n    Pick<FindExtraOptions, \"loadRelationIds\"> &\n    Pick<FindExtraOptions, \"pagination\">;\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class SelectQueryBuilder<Entity> extends QueryBuilder<Entity>\n    implements WhereExpression {\n    protected findOptions: QueryFindOptions<Entity> = {};\n    protected selects: string[] = [];\n    protected joins: {\n        type: \"inner\" | \"left\";\n        alias: string;\n        parentAlias: string;\n        relationMetadata: RelationMetadata;\n        select: boolean;\n    }[] = [];\n    protected conditions: string = \"\";\n    protected orderBys: {\n        alias: string;\n        direction: \"ASC\" | \"DESC\";\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\";\n    }[] = [];\n    protected relationMetadatas: RelationMetadata[] = [];\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    /**\n     * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\n     */\n    constructor(\n        connectionOrQueryBuilder: Connection | QueryBuilder<any>,\n        queryRunner?: QueryRunner\n    ) {\n        // TODO: Proper clone of findOptions field(deep, no as any)\n        super(connectionOrQueryBuilder as any, queryRunner);\n        if (connectionOrQueryBuilder instanceof QueryBuilder) {\n            this.findOptions = (connectionOrQueryBuilder as SelectQueryBuilder<\n                Entity\n            >).findOptions;\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated sql query without parameters being replaced.\n     */\n    getQuery(): string {\n        let sql = this.createSelectExpression();\n        sql += this.createJoinExpression();\n        sql += this.createWhereExpression();\n        sql += this.createGroupByExpression();\n        sql += this.createHavingExpression();\n        sql += this.createOrderByExpression();\n        sql += this.createLimitOffsetExpression();\n        sql += this.createLockExpression();\n        sql = sql.trim();\n        if (this.expressionMap.subQuery) sql = \"(\" + sql + \")\";\n        return sql;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a subquery - query that can be used inside other queries.\n     */\n    subQuery(): SelectQueryBuilder<any> {\n        const qb = this.createQueryBuilder();\n        qb.expressionMap.subQuery = true;\n        qb.expressionMap.parentQueryBuilder = this;\n        return qb;\n    }\n\n    setFindOptions(findOptions: FindOptions<Entity>) {\n        const normalizedFindOptions = normalizeFindOptions(findOptions);\n        this.findOptions = {\n            select: normalizedFindOptions.select,\n            where: normalizedFindOptions.where,\n            relations: normalizedFindOptions.relations,\n            order: normalizedFindOptions.order,\n            skip: normalizedFindOptions.skip,\n            take: normalizedFindOptions.take,\n            pagination:\n                normalizedFindOptions.options &&\n                normalizedFindOptions.options.pagination,\n            loadRelationIds:\n                normalizedFindOptions.options &&\n                normalizedFindOptions.options.loadRelationIds\n        };\n        this.applyFindOptionsOrmOptions(normalizedFindOptions);\n        return this;\n    }\n\n    /**\n     * Creates SELECT query.\n     * Replaces all previous selections if they exist.\n     */\n    select(): this;\n\n    /**\n     * Creates SELECT query.\n     * Replaces all previous selections if they exist.\n     */\n    select(\n        selection: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>,\n        selectionAliasName?: string\n    ): this;\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection: string, selectionAliasName?: string): this;\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection: string[]): this;\n\n    /**\n     * Creates SELECT query based on find options.\n     * Replaces all previous selections if they exist.\n     */\n    select(options: FindOptionsSelect<Entity>): this;\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(\n        selection?:\n            | string\n            | string[]\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)\n            | FindOptionsSelect<Entity>,\n        selectionAliasName?: string\n    ): SelectQueryBuilder<Entity> {\n        this.expressionMap.queryType = \"select\";\n        if (Array.isArray(selection)) {\n            this.expressionMap.selects = (selection as string[]).map(\n                selection => ({ selection: selection })\n            );\n        } else if (selection instanceof Function) {\n            const subQueryBuilder = selection(this.subQuery());\n            this.setParameters(subQueryBuilder.getParameters());\n            this.expressionMap.selects.push({\n                selection: subQueryBuilder.getQuery(),\n                aliasName: selectionAliasName\n            });\n        } else if (selection && typeof selection === \"object\") {\n            this.findOptions.select = selection;\n        } else if (selection) {\n            this.expressionMap.selects = [\n                { selection: selection, aliasName: selectionAliasName }\n            ];\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(\n        selection: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>,\n        selectionAliasName?: string\n    ): this;\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection: string, selectionAliasName?: string): this;\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection: string[]): this;\n\n    /**\n     * Adds new selection to the SELECT query based on find options.\n     */\n    addSelect(options: FindOptionsSelect<Entity>): this;\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(\n        selection:\n            | string\n            | string[]\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)\n            | FindOptionsSelect<Entity>,\n        selectionAliasName?: string\n    ): this {\n        if (!selection) return this;\n\n        if (Array.isArray(selection)) {\n            this.expressionMap.selects = this.expressionMap.selects.concat(\n                (selection as string[]).map(selection => ({\n                    selection: selection\n                }))\n            );\n        } else if (selection instanceof Function) {\n            const subQueryBuilder = selection(this.subQuery());\n            this.setParameters(subQueryBuilder.getParameters());\n            this.expressionMap.selects.push({\n                selection: subQueryBuilder.getQuery(),\n                aliasName: selectionAliasName\n            });\n        } else if (selection && typeof selection === \"object\") {\n            this.findOptions.select = Object.assign(\n                this.findOptions.select,\n                selection\n            );\n        } else if (selection) {\n            this.expressionMap.selects.push({\n                selection: selection,\n                aliasName: selectionAliasName\n            });\n        }\n\n        return this;\n    }\n\n    /**\n     * Sets whether the selection is DISTINCT.\n     */\n    distinct(distinct: boolean = true): this {\n        this.expressionMap.selectDistinct = distinct;\n        return this;\n    }\n\n    /**\n     * Sets the distinct on clause for Postgres.\n     */\n    distinctOn(distinctOn: string[]): this {\n        this.expressionMap.selectDistinctOn = distinctOn;\n        return this;\n    }\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     * Removes all previously set from-s.\n     */\n    from<T>(\n        entityTarget: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>,\n        aliasName: string\n    ): SelectQueryBuilder<T>;\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     * Removes all previously set from-s.\n     */\n    from<T>(\n        entityTarget: ObjectType<T> | string,\n        aliasName: string\n    ): SelectQueryBuilder<T>;\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     * Removes all previously set from-s.\n     */\n    from<T>(\n        entityTarget:\n            | ObjectType<T>\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        aliasName: string\n    ): SelectQueryBuilder<T> {\n        const mainAlias = this.createFromAlias(entityTarget, aliasName);\n        this.expressionMap.setMainAlias(mainAlias);\n        return (this as any) as SelectQueryBuilder<T>;\n    }\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    addFrom<T>(\n        entityTarget: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>,\n        aliasName: string\n    ): SelectQueryBuilder<T>;\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    addFrom<T>(\n        entityTarget: ObjectType<T> | string,\n        aliasName: string\n    ): SelectQueryBuilder<T>;\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    addFrom<T>(\n        entityTarget:\n            | ObjectType<T>\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        aliasName: string\n    ): SelectQueryBuilder<T> {\n        const alias = this.createFromAlias(entityTarget, aliasName);\n        if (!this.expressionMap.mainAlias)\n            this.expressionMap.setMainAlias(alias);\n\n        return (this as any) as SelectQueryBuilder<T>;\n    }\n\n    /**\n     * INNER JOINs (without selection) given subquery.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs (without selection) entity's property.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs (without selection) given entity's table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs (without selection) given table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs (without selection).\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition: string = \"\",\n        parameters?: ObjectLiteral\n    ): this {\n        this.join(\"INNER\", entityOrProperty, alias, condition, parameters);\n        return this;\n    }\n\n    /**\n     * LEFT JOINs (without selection) given subquery.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs (without selection) entity's property.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs (without selection) entity's table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs (without selection) given table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs (without selection).\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition: string = \"\",\n        parameters?: ObjectLiteral\n    ): this {\n        this.join(\"LEFT\", entityOrProperty, alias, condition, parameters);\n        return this;\n    }\n\n    /**\n     * INNER JOINs given subquery and adds all selection properties to SELECT..\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs entity's property and adds all selection properties to SELECT.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs entity and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs table and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition: string = \"\",\n        parameters?: ObjectLiteral\n    ): this {\n        this.addSelect(alias);\n        this.innerJoin(entityOrProperty, alias, condition, parameters);\n        return this;\n    }\n\n    /**\n     * LEFT JOINs given subquery and adds all selection properties to SELECT..\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs entity's property and adds all selection properties to SELECT.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs entity and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        entity: Function | string,\n        alias: string,\n        condition: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs table and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition: string = \"\",\n        parameters?: ObjectLiteral\n    ): this {\n        this.addSelect(alias);\n        this.leftJoin(entityOrProperty, alias, condition, parameters);\n        return this;\n    }\n\n    /**\n     * INNER JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        entity: Function | string,\n        alias: string,\n        condition: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        tableName: string,\n        alias: string,\n        condition: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition: string = \"\",\n        parameters?: ObjectLiteral\n    ): this {\n        this.addSelect(alias);\n        this.join(\n            \"INNER\",\n            entityOrProperty,\n            alias,\n            condition,\n            parameters,\n            mapToProperty,\n            true\n        );\n        return this;\n    }\n\n    /**\n     * INNER JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        entity: Function | string,\n        alias: string,\n        condition: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        tableName: string,\n        alias: string,\n        condition: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition: string = \"\",\n        parameters?: ObjectLiteral\n    ): this {\n        this.addSelect(alias);\n        this.join(\n            \"INNER\",\n            entityOrProperty,\n            alias,\n            condition,\n            parameters,\n            mapToProperty,\n            false\n        );\n        return this;\n    }\n\n    /**\n     * LEFT JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        entity: Function | string,\n        alias: string,\n        condition: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        tableName: string,\n        alias: string,\n        condition: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition: string = \"\",\n        parameters?: ObjectLiteral\n    ): this {\n        this.addSelect(alias);\n        this.join(\n            \"LEFT\",\n            entityOrProperty,\n            alias,\n            condition,\n            parameters,\n            mapToProperty,\n            true\n        );\n        return this;\n    }\n\n    /**\n     * LEFT JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        entity: Function | string,\n        alias: string,\n        condition: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        tableName: string,\n        alias: string,\n        condition: string,\n        parameters?: ObjectLiteral\n    ): this;\n\n    /**\n     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition: string = \"\",\n        parameters?: ObjectLiteral\n    ): this {\n        this.addSelect(alias);\n        this.join(\n            \"LEFT\",\n            entityOrProperty,\n            alias,\n            condition,\n            parameters,\n            mapToProperty,\n            false\n        );\n        return this;\n    }\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, property: string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, entity: Function|string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, tableName: string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, entityOrProperty: Function|string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this {\n    //     const select = new SelectAttribute(this.expressionMap);\n    //     select.mapToProperty = mapToProperty;\n    //     select.entityOrProperty = entityOrProperty;\n    //     select.aliasName = aliasName;\n    //     select.qbFactory = qbFactory;\n    //     return this;\n    // }\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(\n        mapToProperty: string,\n        relationName: string,\n        options?: { disableMixedMap?: boolean }\n    ): this;\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(\n        mapToProperty: string,\n        relationName: string,\n        alias: string,\n        queryBuilderFactory: (\n            qb: SelectQueryBuilder<any>\n        ) => SelectQueryBuilder<any>\n    ): this;\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(\n        mapToProperty: string,\n        relationName: string,\n        aliasNameOrOptions?: string | { disableMixedMap?: boolean },\n        queryBuilderFactory?: (\n            qb: SelectQueryBuilder<any>\n        ) => SelectQueryBuilder<any>\n    ): this {\n        const relationIdAttribute = new RelationIdAttribute(this.expressionMap);\n        relationIdAttribute.mapToProperty = mapToProperty;\n        relationIdAttribute.relationName = relationName;\n        if (typeof aliasNameOrOptions === \"string\")\n            relationIdAttribute.alias = aliasNameOrOptions;\n        if (\n            aliasNameOrOptions instanceof Object &&\n            (aliasNameOrOptions as any).disableMixedMap\n        )\n            relationIdAttribute.disableMixedMap = true;\n\n        relationIdAttribute.queryBuilderFactory = queryBuilderFactory;\n        this.expressionMap.relationIdAttributes.push(relationIdAttribute);\n\n        if (relationIdAttribute.relation.junctionEntityMetadata) {\n            this.expressionMap.createAlias({\n                type: \"other\",\n                name: relationIdAttribute.junctionAlias,\n                metadata: relationIdAttribute.relation.junctionEntityMetadata\n            });\n        }\n        return this;\n    }\n\n    /**\n     * Counts number of entities of entity's relation and maps the value into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationCountAndMap(\n        mapToProperty: string,\n        relationName: string,\n        aliasName?: string,\n        queryBuilderFactory?: (\n            qb: SelectQueryBuilder<any>\n        ) => SelectQueryBuilder<any>\n    ): this {\n        const relationCountAttribute = new RelationCountAttribute(\n            this.expressionMap\n        );\n        relationCountAttribute.mapToProperty = mapToProperty;\n        relationCountAttribute.relationName = relationName;\n        relationCountAttribute.alias = aliasName;\n        relationCountAttribute.queryBuilderFactory = queryBuilderFactory;\n        this.expressionMap.relationCountAttributes.push(relationCountAttribute);\n\n        this.expressionMap.createAlias({\n            type: \"other\",\n            name: relationCountAttribute.junctionAlias\n        });\n        if (relationCountAttribute.relation.junctionEntityMetadata) {\n            this.expressionMap.createAlias({\n                type: \"other\",\n                name: relationCountAttribute.junctionAlias,\n                metadata: relationCountAttribute.relation.junctionEntityMetadata\n            });\n        }\n        return this;\n    }\n\n    /**\n     * Loads all relation ids for all relations of the selected entity.\n     * All relation ids will be mapped to relation property themself.\n     * If array of strings is given then loads only relation ids of the given properties.\n     */\n    loadAllRelationIds(options?: {\n        relations?: string[];\n        disableMixedMap?: boolean;\n    }): this {\n        // todo: add skip relations\n        this.expressionMap.mainAlias!.metadata.relations.forEach(relation => {\n            if (\n                options !== undefined &&\n                options.relations !== undefined &&\n                options.relations.indexOf(relation.propertyPath) === -1\n            )\n                return;\n\n            this.loadRelationIdAndMap(\n                this.expressionMap.mainAlias!.name +\n                    \".\" +\n                    relation.propertyPath,\n                this.expressionMap.mainAlias!.name +\n                    \".\" +\n                    relation.propertyPath,\n                options\n            );\n        });\n        return this;\n    }\n\n    /**\n     * Sets WHERE condition in the query builder.\n     * If you had previously WHERE expression defined,\n     * calling this function will override previously set WHERE conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    where(\n        where:\n            | Brackets\n            | string\n            | ((qb: this) => string)\n            | FindOptionsWhere<Entity>,\n        parameters?: ObjectLiteral\n    ): this {\n        this.expressionMap.wheres = []; // don't move this block below since computeWhereParameter can add where expressions\n\n        if (\n            where &&\n            typeof where === \"object\" &&\n            !(where instanceof Brackets)\n        ) {\n            this.findOptions.where = where;\n        } else {\n            const condition = this.computeWhereParameter(where);\n            if (condition)\n                this.expressionMap.wheres = [\n                    { type: \"simple\", condition: condition }\n                ];\n        }\n\n        if (parameters) this.setParameters(parameters);\n\n        return this;\n    }\n\n    /**\n     * Adds new AND WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andWhere(\n        where:\n            | string\n            | Brackets\n            | ((qb: this) => string)\n            | FindOptionsWhere<Entity>,\n        parameters?: ObjectLiteral\n    ): this {\n        if (\n            where &&\n            typeof where === \"object\" &&\n            !(where instanceof Brackets)\n        ) {\n            this.findOptions.where = where; // todo: implement \"AND\"\n        } else {\n            this.expressionMap.wheres.push({\n                type: \"and\",\n                condition: this.computeWhereParameter(where)\n            });\n        }\n\n        if (parameters) this.setParameters(parameters);\n\n        return this;\n    }\n\n    /**\n     * Adds new OR WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orWhere(\n        where:\n            | Brackets\n            | string\n            | ((qb: this) => string)\n            | FindOptionsWhere<Entity>,\n        parameters?: ObjectLiteral\n    ): this {\n        if (\n            where &&\n            typeof where === \"object\" &&\n            !(where instanceof Brackets)\n        ) {\n            this.findOptions.where = where; // todo: implement \"OR\"\n        } else {\n            this.expressionMap.wheres.push({\n                type: \"or\",\n                condition: this.computeWhereParameter(where)\n            });\n        }\n\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     *\n     * Ids are mixed.\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n     * If you have multiple primary keys you need to pass object with property names and values specified,\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n     */\n    whereInIds(ids: any | any[]): this {\n        return this.where(this.createWhereIdsExpression(ids));\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     *\n     * Ids are mixed.\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n     * If you have multiple primary keys you need to pass object with property names and values specified,\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n     */\n    andWhereInIds(ids: any | any[]): this {\n        return this.andWhere(this.createWhereIdsExpression(ids));\n    }\n\n    /**\n     * Adds new OR WHERE with conditions for the given ids.\n     *\n     * Ids are mixed.\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n     * If you have multiple primary keys you need to pass object with property names and values specified,\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n     */\n    orWhereInIds(ids: any | any[]): this {\n        return this.orWhere(this.createWhereIdsExpression(ids));\n    }\n\n    /**\n     * Sets HAVING condition in the query builder.\n     * If you had previously HAVING expression defined,\n     * calling this function will override previously set HAVING conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    having(having: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.havings.push({ type: \"simple\", condition: having });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new AND HAVING condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andHaving(having: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.havings.push({ type: \"and\", condition: having });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new OR HAVING condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orHaving(having: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.havings.push({ type: \"or\", condition: having });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Sets GROUP BY condition in the query builder.\n     * If you had previously GROUP BY expression defined,\n     * calling this function will override previously set GROUP BY conditions.\n     */\n    groupBy(): this;\n\n    /**\n     * Sets GROUP BY condition in the query builder.\n     * If you had previously GROUP BY expression defined,\n     * calling this function will override previously set GROUP BY conditions.\n     */\n    groupBy(groupBy: string): this;\n\n    /**\n     * Sets GROUP BY condition in the query builder.\n     * If you had previously GROUP BY expression defined,\n     * calling this function will override previously set GROUP BY conditions.\n     */\n    groupBy(groupBy?: string): this {\n        if (groupBy) {\n            this.expressionMap.groupBys = [groupBy];\n        } else {\n            this.expressionMap.groupBys = [];\n        }\n        return this;\n    }\n\n    /**\n     * Adds GROUP BY condition in the query builder.\n     */\n    addGroupBy(groupBy: string): this {\n        this.expressionMap.groupBys.push(groupBy);\n        return this;\n    }\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     *\n     * Calling order by without order set will remove all previously set order bys.\n     */\n    orderBy(): this;\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(\n        sort: string,\n        order?: \"ASC\" | \"DESC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\"\n    ): this;\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(order: OrderByCondition): this;\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(\n        sort?: string | OrderByCondition,\n        order: \"ASC\" | \"DESC\" = \"ASC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\"\n    ): this {\n        if (order !== undefined && order !== \"ASC\" && order !== \"DESC\")\n            throw new Error(\n                `SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`\n            );\n        if (\n            nulls !== undefined &&\n            nulls !== \"NULLS FIRST\" &&\n            nulls !== \"NULLS LAST\"\n        )\n            throw new Error(\n                `SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`\n            );\n\n        if (sort) {\n            if (sort instanceof Object) {\n                this.expressionMap.orderBys = sort as OrderByCondition;\n            } else {\n                if (nulls) {\n                    this.expressionMap.orderBys = {\n                        [sort as string]: { order, nulls }\n                    };\n                } else {\n                    this.expressionMap.orderBys = { [sort as string]: order };\n                }\n            }\n        } else {\n            this.expressionMap.orderBys = {};\n        }\n        return this;\n    }\n\n    /**\n     * Adds ORDER BY condition in the query builder.\n     */\n    addOrderBy(\n        sort: string,\n        order: \"ASC\" | \"DESC\" = \"ASC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\"\n    ): this {\n        if (order !== undefined && order !== \"ASC\" && order !== \"DESC\")\n            throw new Error(\n                `SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`\n            );\n        if (\n            nulls !== undefined &&\n            nulls !== \"NULLS FIRST\" &&\n            nulls !== \"NULLS LAST\"\n        )\n            throw new Error(\n                `SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`\n            );\n\n        if (nulls) {\n            this.expressionMap.orderBys[sort] = { order, nulls };\n        } else {\n            this.expressionMap.orderBys[sort] = order;\n        }\n        return this;\n    }\n\n    /**\n     * Set's LIMIT - maximum number of rows to be selected.\n     * NOTE that it may not work as you expect if you are using joins.\n     * If you want to implement pagination, and you are having join in your query,\n     * then use instead take method instead.\n     */\n    limit(limit?: number): this {\n        this.expressionMap.limit = this.normalizeNumber(limit);\n        if (\n            this.expressionMap.limit !== undefined &&\n            isNaN(this.expressionMap.limit)\n        )\n            throw new Error(\n                `Provided \"limit\" value is not a number. Please provide a numeric value.`\n            );\n\n        return this;\n    }\n\n    /**\n     * Set's OFFSET - selection offset.\n     * NOTE that it may not work as you expect if you are using joins.\n     * If you want to implement pagination, and you are having join in your query,\n     * then use instead skip method instead.\n     */\n    offset(offset?: number): this {\n        this.expressionMap.offset = this.normalizeNumber(offset);\n        if (\n            this.expressionMap.offset !== undefined &&\n            isNaN(this.expressionMap.offset)\n        )\n            throw new Error(\n                `Provided \"offset\" value is not a number. Please provide a numeric value.`\n            );\n\n        return this;\n    }\n\n    /**\n     * Sets maximal number of entities to take.\n     */\n    take(take?: number): this {\n        this.expressionMap.take = this.normalizeNumber(take);\n        if (\n            this.expressionMap.take !== undefined &&\n            isNaN(this.expressionMap.take)\n        )\n            throw new Error(\n                `Provided \"take\" value is not a number. Please provide a numeric value.`\n            );\n\n        return this;\n    }\n\n    /**\n     * Sets number of entities to skip.\n     */\n    skip(skip?: number): this {\n        this.expressionMap.skip = this.normalizeNumber(skip);\n        if (\n            this.expressionMap.skip !== undefined &&\n            isNaN(this.expressionMap.skip)\n        )\n            throw new Error(\n                `Provided \"skip\" value is not a number. Please provide a numeric value.`\n            );\n\n        return this;\n    }\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(lockMode: \"optimistic\", lockVersion: number | Date): this;\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(\n        lockMode: \"pessimistic_read\" | \"pessimistic_write\" | \"dirty_read\"\n    ): this;\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(\n        lockMode:\n            | \"optimistic\"\n            | \"pessimistic_read\"\n            | \"pessimistic_write\"\n            | \"dirty_read\",\n        lockVersion?: number | Date\n    ): this {\n        this.expressionMap.lockMode = lockMode;\n        this.expressionMap.lockVersion = lockVersion;\n        return this;\n    }\n\n    /**\n     * Gets first raw result returned by execution of generated query builder sql.\n     */\n    async getRawOne(): Promise<any> {\n        return (await this.getRawMany())[0];\n    }\n\n    /**\n     * Gets all raw results returned by execution of generated query builder sql.\n     */\n    async getRawMany(): Promise<any[]> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n\n        this.expressionMap.queryEntity = false;\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs: boolean = false;\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n            this.applyFindOptions();\n\n            const results = await this.loadRawResults(queryRunner);\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n                if (this.expressionMap.callObservers)\n                    await new ObserverExecutor(\n                        this.connection.observers\n                    ).execute();\n            }\n\n            return results;\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                } catch (rollbackError) {}\n            }\n            throw error;\n        } finally {\n            if (queryRunner !== this.queryRunner) {\n                // means we created our own query runner\n                await queryRunner.release();\n            }\n        }\n    }\n\n    /**\n     * Executes sql generated by query builder and returns object with raw results and entities created from them.\n     */\n    async getRawAndEntities(): Promise<{ entities: Entity[]; raw: any[] }> {\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs: boolean = false;\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n\n            this.expressionMap.queryEntity = true;\n            this.applyFindOptions();\n            const results = await this.executeEntitiesAndRawResults(\n                queryRunner\n            );\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n                if (this.expressionMap.callObservers)\n                    await new ObserverExecutor(\n                        this.connection.observers\n                    ).execute();\n            }\n\n            return results;\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                } catch (rollbackError) {}\n            }\n            throw error;\n        } finally {\n            if (queryRunner !== this.queryRunner)\n                // means we created our own query runner\n                await queryRunner.release();\n        }\n    }\n\n    /**\n     * Gets single entity returned by execution of generated query builder sql.\n     */\n    async getOne(): Promise<Entity | undefined> {\n        const results = await this.getRawAndEntities();\n        const result = results.entities[0] as any;\n\n        if (\n            result &&\n            this.expressionMap.lockMode === \"optimistic\" &&\n            this.expressionMap.lockVersion\n        ) {\n            const metadata = this.expressionMap.mainAlias!.metadata;\n\n            if (this.expressionMap.lockVersion instanceof Date) {\n                const actualVersion = metadata.updateDateColumn!.getEntityValue(\n                    result\n                ); // what if columns arent set?\n                if (\n                    actualVersion.getTime() !==\n                    this.expressionMap.lockVersion.getTime()\n                )\n                    throw new OptimisticLockVersionMismatchError(\n                        metadata.name,\n                        this.expressionMap.lockVersion,\n                        actualVersion\n                    );\n            } else {\n                const actualVersion = metadata.versionColumn!.getEntityValue(\n                    result\n                ); // what if columns arent set?\n                if (actualVersion !== this.expressionMap.lockVersion)\n                    throw new OptimisticLockVersionMismatchError(\n                        metadata.name,\n                        this.expressionMap.lockVersion,\n                        actualVersion\n                    );\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Gets entities returned by execution of generated query builder sql.\n     */\n    async getMany(): Promise<Entity[]> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n\n        const results = await this.getRawAndEntities();\n        return results.entities;\n    }\n\n    /**\n     * Gets count - number of entities selected by sql generated by this query builder.\n     * Count excludes all limitations set by setFirstResult and setMaxResults methods call.\n     */\n    async getCount(): Promise<number> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs: boolean = false;\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n\n            this.expressionMap.queryEntity = false;\n            this.applyFindOptions();\n            const results = await this.executeCountQuery(queryRunner);\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n                if (this.expressionMap.callObservers)\n                    await new ObserverExecutor(\n                        this.connection.observers\n                    ).execute();\n            }\n\n            return results;\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                } catch (rollbackError) {}\n            }\n            throw error;\n        } finally {\n            if (queryRunner !== this.queryRunner)\n                // means we created our own query runner\n                await queryRunner.release();\n        }\n    }\n\n    /**\n     * Executes built SQL query and returns entities and overall entities count (without limitation).\n     * This method is useful to build pagination.\n     */\n    async getManyAndCount(): Promise<[Entity[], number]> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs: boolean = false;\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n\n            this.applyFindOptions();\n            this.expressionMap.queryEntity = true;\n            const entitiesAndRaw = await this.executeEntitiesAndRawResults(\n                queryRunner\n            );\n            this.expressionMap.queryEntity = false;\n            const count = await this.executeCountQuery(queryRunner);\n            const results: [Entity[], number] = [\n                entitiesAndRaw.entities,\n                count\n            ];\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n                if (this.expressionMap.callObservers)\n                    await new ObserverExecutor(\n                        this.connection.observers\n                    ).execute();\n            }\n\n            return results;\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                } catch (rollbackError) {}\n            }\n            throw error;\n        } finally {\n            if (queryRunner !== this.queryRunner)\n                // means we created our own query runner\n                await queryRunner.release();\n        }\n    }\n\n    /**\n     * Executes built SQL query and returns raw data stream.\n     */\n    async stream(): Promise<ReadStream> {\n        this.expressionMap.queryEntity = false;\n        const [sql, parameters] = this.getQueryAndParameters();\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs: boolean = false;\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n\n            const releaseFn = () => {\n                if (queryRunner !== this.queryRunner)\n                    // means we created our own query runner\n                    return queryRunner.release();\n                return;\n            };\n            const results = queryRunner.stream(\n                sql,\n                parameters,\n                releaseFn,\n                releaseFn\n            );\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n                if (this.expressionMap.callObservers)\n                    await new ObserverExecutor(\n                        this.connection.observers\n                    ).execute();\n            }\n\n            return results;\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                } catch (rollbackError) {}\n            }\n            throw error;\n        } finally {\n            if (queryRunner !== this.queryRunner)\n                // means we created our own query runner\n                await queryRunner.release();\n        }\n    }\n\n    /**\n     * Enables or disables query result caching.\n     */\n    cache(enabled: boolean): this;\n\n    /**\n     * Enables query result caching and sets in milliseconds in which cache will expire.\n     * If not set then global caching time will be used.\n     */\n    cache(milliseconds: number): this;\n\n    /**\n     * Enables query result caching and sets cache id and milliseconds in which cache will expire.\n     */\n    cache(id: any, milliseconds?: number): this;\n\n    /**\n     * Enables or disables query result caching.\n     */\n    cache(\n        enabledOrMillisecondsOrId: boolean | number | string,\n        maybeMilliseconds?: number\n    ): this {\n        if (typeof enabledOrMillisecondsOrId === \"boolean\") {\n            this.expressionMap.cache = enabledOrMillisecondsOrId;\n        } else if (typeof enabledOrMillisecondsOrId === \"number\") {\n            this.expressionMap.cache = true;\n            this.expressionMap.cacheDuration = enabledOrMillisecondsOrId;\n        } else if (\n            typeof enabledOrMillisecondsOrId === \"string\" ||\n            typeof enabledOrMillisecondsOrId === \"number\"\n        ) {\n            this.expressionMap.cache = true;\n            this.expressionMap.cacheId = enabledOrMillisecondsOrId;\n        }\n\n        if (maybeMilliseconds) {\n            this.expressionMap.cacheDuration = maybeMilliseconds;\n        }\n\n        return this;\n    }\n\n    /**\n     * Sets extra options that can be used to configure how query builder works.\n     */\n    setOption(option: SelectQueryBuilderOption): this {\n        this.expressionMap.options.push(option);\n        return this;\n    }\n\n    /**\n     * Disables eager relations.\n     */\n    disableEagerRelations(disabled: boolean = true) {\n        this.expressionMap.eagerRelations = disabled === true ? false : true;\n        return this;\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    protected join(\n        direction: \"INNER\" | \"LEFT\",\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        aliasName: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n        mapToProperty?: string,\n        isMappingMany?: boolean\n    ): void {\n        this.setParameters(parameters || {});\n\n        const joinAttribute = new JoinAttribute(\n            this.connection,\n            this.expressionMap\n        );\n        joinAttribute.direction = direction;\n        joinAttribute.mapToProperty = mapToProperty;\n        joinAttribute.isMappingMany = isMappingMany;\n        joinAttribute.entityOrProperty = entityOrProperty; // relationName\n        joinAttribute.condition = condition; // joinInverseSideCondition\n        // joinAttribute.junctionAlias = joinAttribute.relation.isOwning ? parentAlias + \"_\" + destinationTableAlias : destinationTableAlias + \"_\" + parentAlias;\n        this.expressionMap.joinAttributes.push(joinAttribute);\n\n        if (joinAttribute.metadata) {\n            // todo: find and set metadata right there?\n            joinAttribute.alias = this.expressionMap.createAlias({\n                type: \"join\",\n                name: aliasName,\n                metadata: joinAttribute.metadata\n            });\n            if (\n                joinAttribute.relation &&\n                joinAttribute.relation.junctionEntityMetadata\n            ) {\n                this.expressionMap.createAlias({\n                    type: \"join\",\n                    name: joinAttribute.junctionAlias,\n                    metadata: joinAttribute.relation.junctionEntityMetadata\n                });\n            }\n        } else {\n            let subQuery: string = \"\";\n            if (entityOrProperty instanceof Function) {\n                const subQueryBuilder: SelectQueryBuilder<any> = (entityOrProperty as any)(\n                    ((this as any) as SelectQueryBuilder<any>).subQuery()\n                );\n                this.setParameters(subQueryBuilder.getParameters());\n                subQuery = subQueryBuilder.getQuery();\n            } else {\n                subQuery = entityOrProperty;\n            }\n            const isSubQuery =\n                entityOrProperty instanceof Function ||\n                (entityOrProperty.substr(0, 1) === \"(\" &&\n                    entityOrProperty.substr(-1) === \")\");\n            joinAttribute.alias = this.expressionMap.createAlias({\n                type: \"join\",\n                name: aliasName,\n                tablePath:\n                    isSubQuery === false\n                        ? (entityOrProperty as string)\n                        : undefined,\n                subQuery: isSubQuery === true ? subQuery : undefined\n            });\n        }\n    }\n\n    /**\n     * Creates \"SELECT FROM\" part of SQL query.\n     */\n    protected createSelectExpression() {\n        if (!this.expressionMap.mainAlias)\n            throw new Error(\n                \"Cannot build query because main alias is not set (call qb#from method)\"\n            );\n\n        // todo throw exception if selects or from is missing\n\n        const allSelects: SelectQuery[] = [];\n        const excludedSelects: SelectQuery[] = [];\n\n        if (this.expressionMap.mainAlias.hasMetadata) {\n            const metadata = this.expressionMap.mainAlias.metadata;\n            allSelects.push(\n                ...this.buildEscapedEntityColumnSelects(\n                    this.expressionMap.mainAlias.name,\n                    metadata\n                )\n            );\n            excludedSelects.push(\n                ...this.findEntityColumnSelects(\n                    this.expressionMap.mainAlias.name,\n                    metadata\n                )\n            );\n        }\n\n        // add selects from joins\n        this.expressionMap.joinAttributes.forEach(join => {\n            if (join.metadata) {\n                allSelects.push(\n                    ...this.buildEscapedEntityColumnSelects(\n                        join.alias.name!,\n                        join.metadata\n                    )\n                );\n                excludedSelects.push(\n                    ...this.findEntityColumnSelects(\n                        join.alias.name!,\n                        join.metadata\n                    )\n                );\n            } else {\n                const hasMainAlias = this.expressionMap.selects.some(\n                    select => select.selection === join.alias.name\n                );\n                if (hasMainAlias) {\n                    allSelects.push({\n                        selection: this.escape(join.alias.name!) + \".*\"\n                    });\n                    const excludedSelect = this.expressionMap.selects.find(\n                        select => select.selection === join.alias.name\n                    );\n                    excludedSelects.push(excludedSelect!);\n                }\n            }\n        });\n\n        // add all other selects\n        this.expressionMap.selects\n            .filter(select => excludedSelects.indexOf(select) === -1)\n            .forEach(select =>\n                allSelects.push({\n                    selection: this.replacePropertyNames(select.selection),\n                    aliasName: select.aliasName\n                })\n            );\n\n        // if still selection is empty, then simply set it to all (*)\n        if (allSelects.length === 0) allSelects.push({ selection: \"*\" });\n\n        let lock: string = \"\";\n        if (this.connection.driver instanceof SqlServerDriver) {\n            switch (this.expressionMap.lockMode) {\n                case \"pessimistic_read\":\n                    lock = \" WITH (HOLDLOCK, ROWLOCK)\";\n                    break;\n                case \"pessimistic_write\":\n                    lock = \" WITH (UPDLOCK, ROWLOCK)\";\n                    break;\n                case \"dirty_read\":\n                    lock = \" WITH (NOLOCK)\";\n                    break;\n            }\n        }\n\n        // create a selection query\n        const froms = this.expressionMap.aliases\n            .filter(\n                alias =>\n                    alias.type === \"from\" && (alias.tablePath || alias.subQuery)\n            )\n            .map(alias => {\n                if (alias.subQuery)\n                    return alias.subQuery + \" \" + this.escape(alias.name);\n\n                return (\n                    this.getTableName(alias.tablePath!) +\n                    \" \" +\n                    this.escape(alias.name)\n                );\n            });\n\n        const select = this.createSelectDistinctExpression();\n        const selection = allSelects\n            .map(\n                select =>\n                    select.selection +\n                    (select.aliasName\n                        ? \" AS \" + this.escape(select.aliasName)\n                        : \"\")\n            )\n            .join(\", \");\n\n        return select + selection + \" FROM \" + froms.join(\", \") + lock;\n    }\n\n    /**\n     * Creates select | select distinct part of SQL query.\n     */\n    protected createSelectDistinctExpression(): string {\n        const { selectDistinct, selectDistinctOn } = this.expressionMap;\n        const { driver } = this.connection;\n\n        let select = \"SELECT \";\n        if (driver instanceof PostgresDriver && selectDistinctOn.length > 0) {\n            const selectDistinctOnMap = selectDistinctOn\n                .map(on => this.replacePropertyNames(on))\n                .join(\", \");\n\n            select = `SELECT DISTINCT ON (${selectDistinctOnMap}) `;\n        } else if (selectDistinct) {\n            select = \"SELECT DISTINCT \";\n        }\n\n        return select;\n    }\n\n    /**\n     * Creates \"JOIN\" part of SQL query.\n     */\n    protected createJoinExpression(): string {\n        // examples:\n        // select from owning side\n        // qb.select(\"post\")\n        //     .leftJoinAndSelect(\"post.category\", \"category\");\n        // select from non-owning side\n        // qb.select(\"category\")\n        //     .leftJoinAndSelect(\"category.post\", \"post\");\n\n        const joins = this.expressionMap.joinAttributes.map(joinAttr => {\n            const relation = joinAttr.relation;\n            const destinationTableName = joinAttr.tablePath;\n            const destinationTableAlias = joinAttr.alias.name;\n            const appendedCondition = joinAttr.condition\n                ? \" AND (\" + joinAttr.condition + \")\"\n                : \"\";\n            const parentAlias = joinAttr.parentAlias;\n\n            // if join was build without relation (e.g. without \"post.category\") then it means that we have direct\n            // table to join, without junction table involved. This means we simply join direct table.\n            if (!parentAlias || !relation) {\n                const destinationJoin = joinAttr.alias.subQuery\n                    ? joinAttr.alias.subQuery\n                    : this.getTableName(destinationTableName);\n                return (\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    destinationJoin +\n                    \" \" +\n                    this.escape(destinationTableAlias) +\n                    (joinAttr.condition\n                        ? \" ON \" + this.replacePropertyNames(joinAttr.condition)\n                        : \"\")\n                );\n            }\n\n            // if real entity relation is involved\n            if (relation.isManyToOne || relation.isOneToOneOwner) {\n                // JOIN `category` `category` ON `category`.`id` = `post`.`categoryId`\n                const condition = relation.joinColumns\n                    .map(joinColumn => {\n                        return (\n                            destinationTableAlias +\n                            \".\" +\n                            joinColumn.referencedColumn!.propertyPath +\n                            \"=\" +\n                            parentAlias +\n                            \".\" +\n                            relation.propertyPath +\n                            \".\" +\n                            joinColumn.referencedColumn!.propertyPath\n                        );\n                    })\n                    .join(\" AND \");\n\n                return (\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    this.getTableName(destinationTableName) +\n                    \" \" +\n                    this.escape(destinationTableAlias) +\n                    \" ON \" +\n                    this.replacePropertyNames(condition + appendedCondition)\n                );\n            } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n                // JOIN `post` `post` ON `post`.`categoryId` = `category`.`id`\n                const condition = relation\n                    .inverseRelation!.joinColumns.map(joinColumn => {\n                        return (\n                            destinationTableAlias +\n                            \".\" +\n                            relation.inverseRelation!.propertyPath +\n                            \".\" +\n                            joinColumn.referencedColumn!.propertyPath +\n                            \"=\" +\n                            parentAlias +\n                            \".\" +\n                            joinColumn.referencedColumn!.propertyPath\n                        );\n                    })\n                    .join(\" AND \");\n\n                return (\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    this.getTableName(destinationTableName) +\n                    \" \" +\n                    this.escape(destinationTableAlias) +\n                    \" ON \" +\n                    this.replacePropertyNames(condition + appendedCondition)\n                );\n            } else {\n                // means many-to-many\n                const junctionTableName = relation.junctionEntityMetadata!\n                    .tablePath;\n\n                const junctionAlias = joinAttr.junctionAlias;\n                let junctionCondition = \"\",\n                    destinationCondition = \"\";\n\n                if (relation.isOwning) {\n                    junctionCondition = relation.joinColumns\n                        .map(joinColumn => {\n                            // `post_category`.`postId` = `post`.`id`\n                            return (\n                                junctionAlias +\n                                \".\" +\n                                joinColumn.propertyPath +\n                                \"=\" +\n                                parentAlias +\n                                \".\" +\n                                joinColumn.referencedColumn!.propertyPath\n                            );\n                        })\n                        .join(\" AND \");\n\n                    destinationCondition = relation.inverseJoinColumns\n                        .map(joinColumn => {\n                            // `category`.`id` = `post_category`.`categoryId`\n                            return (\n                                destinationTableAlias +\n                                \".\" +\n                                joinColumn.referencedColumn!.propertyPath +\n                                \"=\" +\n                                junctionAlias +\n                                \".\" +\n                                joinColumn.propertyPath\n                            );\n                        })\n                        .join(\" AND \");\n                } else {\n                    junctionCondition = relation\n                        .inverseRelation!.inverseJoinColumns.map(joinColumn => {\n                            // `post_category`.`categoryId` = `category`.`id`\n                            return (\n                                junctionAlias +\n                                \".\" +\n                                joinColumn.propertyPath +\n                                \"=\" +\n                                parentAlias +\n                                \".\" +\n                                joinColumn.referencedColumn!.propertyPath\n                            );\n                        })\n                        .join(\" AND \");\n\n                    destinationCondition = relation\n                        .inverseRelation!.joinColumns.map(joinColumn => {\n                            // `post`.`id` = `post_category`.`postId`\n                            return (\n                                destinationTableAlias +\n                                \".\" +\n                                joinColumn.referencedColumn!.propertyPath +\n                                \"=\" +\n                                junctionAlias +\n                                \".\" +\n                                joinColumn.propertyPath\n                            );\n                        })\n                        .join(\" AND \");\n                }\n\n                return (\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    this.getTableName(junctionTableName) +\n                    \" \" +\n                    this.escape(junctionAlias) +\n                    \" ON \" +\n                    this.replacePropertyNames(junctionCondition) +\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    this.getTableName(destinationTableName) +\n                    \" \" +\n                    this.escape(destinationTableAlias) +\n                    \" ON \" +\n                    this.replacePropertyNames(\n                        destinationCondition + appendedCondition\n                    )\n                );\n            }\n        });\n\n        return joins.join(\" \");\n    }\n\n    /**\n     * Creates \"GROUP BY\" part of SQL query.\n     */\n    protected createGroupByExpression() {\n        if (!this.expressionMap.groupBys || !this.expressionMap.groupBys.length)\n            return \"\";\n        return (\n            \" GROUP BY \" +\n            this.replacePropertyNames(this.expressionMap.groupBys.join(\", \"))\n        );\n    }\n\n    /**\n     * Creates \"ORDER BY\" part of SQL query.\n     */\n    protected createOrderByExpression() {\n        const orderBys = this.expressionMap.allOrderBys;\n        if (Object.keys(orderBys).length > 0)\n            return (\n                \" ORDER BY \" +\n                Object.keys(orderBys)\n                    .map(columnName => {\n                        if (typeof orderBys[columnName] === \"string\") {\n                            return (\n                                this.replacePropertyNames(columnName) +\n                                \" \" +\n                                orderBys[columnName]\n                            );\n                        } else {\n                            return (\n                                this.replacePropertyNames(columnName) +\n                                \" \" +\n                                (orderBys[columnName] as any).order +\n                                \" \" +\n                                (orderBys[columnName] as any).nulls\n                            );\n                        }\n                    })\n                    .join(\", \")\n            );\n\n        return \"\";\n    }\n\n    /**\n     * Creates \"LIMIT\" and \"OFFSET\" parts of SQL query.\n     */\n    protected createLimitOffsetExpression(): string {\n        // in the case if nothing is joined in the query builder we don't need to make two requests to get paginated results\n        // we can use regular limit / offset, that's why we add offset and limit construction here based on skip and take values\n        let offset: number | undefined = this.expressionMap.offset,\n            limit: number | undefined = this.expressionMap.limit;\n        if (\n            !offset &&\n            !limit &&\n            this.expressionMap.joinAttributes.length === 0\n        ) {\n            offset = this.expressionMap.skip;\n            limit = this.expressionMap.take;\n        }\n\n        if (this.connection.driver instanceof SqlServerDriver) {\n            // Due to a limitation in SQL Server's parser implementation it does not support using\n            // OFFSET or FETCH NEXT without an ORDER BY clause being provided. In cases where the\n            // user does not request one we insert a dummy ORDER BY that does nothing and should\n            // have no effect on the query planner or on the order of the results returned.\n            // https://dba.stackexchange.com/a/193799\n            let prefix = \"\";\n            if (\n                (limit || offset) &&\n                Object.keys(this.expressionMap.allOrderBys).length <= 0\n            ) {\n                prefix = \" ORDER BY (SELECT NULL)\";\n            }\n\n            if (limit && offset)\n                return (\n                    prefix +\n                    \" OFFSET \" +\n                    offset +\n                    \" ROWS FETCH NEXT \" +\n                    limit +\n                    \" ROWS ONLY\"\n                );\n            if (limit)\n                return (\n                    prefix + \" OFFSET 0 ROWS FETCH NEXT \" + limit + \" ROWS ONLY\"\n                );\n            if (offset) return prefix + \" OFFSET \" + offset + \" ROWS\";\n        } else if (\n            this.connection.driver instanceof MysqlDriver ||\n            this.connection.driver instanceof AuroraDataApiDriver\n        ) {\n            if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset;\n            if (limit) return \" LIMIT \" + limit;\n            if (offset) throw new OffsetWithoutLimitNotSupportedError(\"MySQL\");\n        } else if (this.connection.driver instanceof AbstractSqliteDriver) {\n            if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset;\n            if (limit) return \" LIMIT \" + limit;\n            if (offset) return \" LIMIT -1 OFFSET \" + offset;\n        } else if (this.connection.driver instanceof OracleDriver) {\n            if (limit && offset)\n                return (\n                    \" OFFSET \" +\n                    offset +\n                    \" ROWS FETCH NEXT \" +\n                    limit +\n                    \" ROWS ONLY\"\n                );\n            if (limit) return \" FETCH NEXT \" + limit + \" ROWS ONLY\";\n            if (offset) return \" OFFSET \" + offset + \" ROWS\";\n        } else {\n            if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset;\n            if (limit) return \" LIMIT \" + limit;\n            if (offset) return \" OFFSET \" + offset;\n        }\n\n        return \"\";\n    }\n\n    /**\n     * Creates \"LOCK\" part of SQL query.\n     */\n    protected createLockExpression(): string {\n        const driver = this.connection.driver;\n        switch (this.expressionMap.lockMode) {\n            case \"pessimistic_read\":\n                if (\n                    driver instanceof MysqlDriver ||\n                    driver instanceof AuroraDataApiDriver\n                ) {\n                    return \" LOCK IN SHARE MODE\";\n                } else if (driver instanceof PostgresDriver) {\n                    return \" FOR SHARE\";\n                } else if (driver instanceof OracleDriver) {\n                    return \" FOR UPDATE\";\n                } else if (driver instanceof SqlServerDriver) {\n                    return \"\";\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n            case \"pessimistic_write\":\n                if (\n                    driver instanceof MysqlDriver ||\n                    driver instanceof AuroraDataApiDriver ||\n                    driver instanceof PostgresDriver ||\n                    driver instanceof OracleDriver\n                ) {\n                    return \" FOR UPDATE\";\n                } else if (driver instanceof SqlServerDriver) {\n                    return \"\";\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n            default:\n                return \"\";\n        }\n    }\n\n    /**\n     * Creates \"HAVING\" part of SQL query.\n     */\n    protected createHavingExpression() {\n        if (!this.expressionMap.havings || !this.expressionMap.havings.length)\n            return \"\";\n        const conditions = this.expressionMap.havings\n            .map((having, index) => {\n                switch (having.type) {\n                    case \"and\":\n                        return (\n                            (index > 0 ? \"AND \" : \"\") +\n                            this.replacePropertyNames(having.condition)\n                        );\n                    case \"or\":\n                        return (\n                            (index > 0 ? \"OR \" : \"\") +\n                            this.replacePropertyNames(having.condition)\n                        );\n                    default:\n                        return this.replacePropertyNames(having.condition);\n                }\n            })\n            .join(\" \");\n\n        if (!conditions.length) return \"\";\n        return \" HAVING \" + conditions;\n    }\n\n    protected buildEscapedEntityColumnSelects(\n        aliasName: string,\n        metadata: EntityMetadata\n    ): SelectQuery[] {\n        const hasMainAlias = this.expressionMap.selects.some(\n            select => select.selection === aliasName\n        );\n\n        const columns: ColumnMetadata[] = [];\n        if (hasMainAlias) {\n            columns.push(\n                ...metadata.columns.filter(column => column.isSelect === true)\n            );\n        }\n        columns.push(\n            ...metadata.columns.filter(column =>\n                this.expressionMap.selects.some(\n                    select =>\n                        select.selection ===\n                        aliasName + \".\" + column.propertyPath\n                )\n            )\n        );\n\n        // if user used partial selection and did not select some primary columns which are required to be selected\n        // we select those primary columns and mark them as \"virtual\". Later virtual column values will be removed from final entity\n        // to make entity contain exactly what user selected\n        if (columns.length === 0)\n            // however not in the case when nothing (even partial) was selected from this target (for example joins without selection)\n            return [];\n\n        const nonSelectedPrimaryColumns = this.expressionMap.queryEntity\n            ? metadata.primaryColumns.filter(\n                  primaryColumn => columns.indexOf(primaryColumn) === -1\n              )\n            : [];\n        const allColumns = [...columns, ...nonSelectedPrimaryColumns];\n\n        return allColumns.map(column => {\n            const selection = this.expressionMap.selects.find(\n                select =>\n                    select.selection === aliasName + \".\" + column.propertyPath\n            );\n            let selectionPath =\n                this.escape(aliasName) + \".\" + this.escape(column.databaseName);\n            if (\n                this.connection.driver.spatialTypes.indexOf(column.type) !== -1\n            ) {\n                if (\n                    this.connection.driver instanceof MysqlDriver ||\n                    this.connection.driver instanceof AuroraDataApiDriver\n                ) {\n                    const useLegacy = this.connection.driver.options\n                        .legacySpatialSupport;\n                    const asText = useLegacy ? \"AsText\" : \"ST_AsText\";\n                    selectionPath = `${asText}(${selectionPath})`;\n                }\n\n                if (this.connection.driver instanceof PostgresDriver)\n                    // cast to JSON to trigger parsing in the driver\n                    selectionPath = `ST_AsGeoJSON(${selectionPath})::json`;\n\n                if (this.connection.driver instanceof SqlServerDriver)\n                    selectionPath = `${selectionPath}.ToString()`;\n            }\n            return {\n                selection: selectionPath,\n                aliasName:\n                    selection && selection.aliasName\n                        ? selection.aliasName\n                        : DriverUtils.buildColumnAlias(\n                              this.connection.driver,\n                              aliasName,\n                              column.databaseName\n                          ),\n                // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!\n                virtual: selection\n                    ? selection.virtual === true\n                    : hasMainAlias\n                    ? false\n                    : true\n            };\n        });\n    }\n\n    protected findEntityColumnSelects(\n        aliasName: string,\n        metadata: EntityMetadata\n    ): SelectQuery[] {\n        const mainSelect = this.expressionMap.selects.find(\n            select => select.selection === aliasName\n        );\n        if (mainSelect) return [mainSelect];\n\n        return this.expressionMap.selects.filter(select => {\n            return metadata.columns.some(\n                column =>\n                    select.selection === aliasName + \".\" + column.propertyPath\n            );\n        });\n    }\n\n    protected applyFindOptions() {\n        if (this.expressionMap.mainAlias!.hasMetadata) {\n            if (this.findOptions.select)\n                this.buildSelect(\n                    this.findOptions.select,\n                    this.expressionMap.mainAlias!.metadata,\n                    this.expressionMap.mainAlias!.name\n                );\n\n            if (this.findOptions.where)\n                this.conditions = this.buildWhere(\n                    this.findOptions.where,\n                    this.expressionMap.mainAlias!.metadata,\n                    this.expressionMap.mainAlias!.name\n                );\n\n            if (this.findOptions.order)\n                this.buildOrder(\n                    this.findOptions.order,\n                    this.expressionMap.mainAlias!.metadata,\n                    this.expressionMap.mainAlias!.name\n                );\n\n            if (this.findOptions.relations)\n                this.buildRelations(\n                    this.findOptions.relations,\n                    this.expressionMap.mainAlias!.metadata\n                );\n\n            if (this.selects.length) this.select(this.selects);\n\n            // apply joins\n            if (this.joins.length) {\n                this.joins.forEach(join => {\n                    if (join.select) {\n                        if (join.type === \"inner\") {\n                            this.innerJoinAndSelect(\n                                `${join.parentAlias}.${join.relationMetadata.propertyPath}`,\n                                join.alias\n                            );\n                        } else {\n                            this.leftJoinAndSelect(\n                                `${join.parentAlias}.${join.relationMetadata.propertyPath}`,\n                                join.alias\n                            );\n                        }\n                    } else {\n                        if (join.type === \"inner\") {\n                            this.innerJoin(\n                                `${join.parentAlias}.${join.relationMetadata.propertyPath}`,\n                                join.alias\n                            );\n                        } else {\n                            this.leftJoin(\n                                `${join.parentAlias}.${join.relationMetadata.propertyPath}`,\n                                join.alias\n                            );\n                        }\n                    }\n                });\n            }\n\n            if (this.conditions.length)\n                this.andWhere(\n                    this.conditions.substr(0, 1) !== \"(\"\n                        ? \"(\" + this.conditions + \")\"\n                        : this.conditions\n                ); // temporary and where and braces\n\n            // apply offset\n            if (this.findOptions.skip !== undefined) {\n                if (this.findOptions.pagination === false) {\n                    this.offset(this.findOptions.skip);\n                } else {\n                    this.skip(this.findOptions.skip);\n                }\n            }\n\n            // apply limit\n            if (this.findOptions.take !== undefined) {\n                if (this.findOptions.pagination === false) {\n                    this.limit(this.findOptions.take);\n                } else {\n                    this.take(this.findOptions.take);\n                }\n            }\n\n            if (this.orderBys.length) {\n                this.orderBys.forEach(orderBy => {\n                    this.addOrderBy(\n                        orderBy.alias,\n                        orderBy.direction,\n                        orderBy.nulls\n                    );\n                });\n            }\n\n            if (this.expressionMap.eagerRelations === true) {\n                const manuallyJoinedRelations = this.expressionMap.joinAttributes\n                    .filter(join => join.relationPropertyPath)\n                    .map(\n                        join =>\n                            join.parentAlias + \".\" + join.relationPropertyPath\n                    );\n                const joinEagerRelations = (\n                    alias: string,\n                    metadata: EntityMetadata\n                ) => {\n                    metadata.eagerRelations.forEach(relation => {\n                        const relationAlias = this.connection.namingStrategy.eagerJoinRelationAlias(\n                            alias,\n                            relation.propertyPath\n                        );\n                        const path = alias + \".\" + relation.propertyPath;\n                        if (manuallyJoinedRelations.indexOf(path) === -1) {\n                            // This alias+propertyPath was already joined manually\n                            this.leftJoinAndSelect(path, relationAlias);\n                        }\n                        joinEagerRelations(\n                            relationAlias,\n                            relation.inverseEntityMetadata\n                        );\n                    });\n                };\n                joinEagerRelations(\n                    this.expressionMap.mainAlias!.name,\n                    this.expressionMap.mainAlias!.metadata\n                );\n            }\n\n            if (this.findOptions.loadRelationIds === true) {\n                this.loadAllRelationIds();\n            } else if (this.findOptions.loadRelationIds instanceof Object) {\n                this.loadAllRelationIds(\n                    this.findOptions.loadRelationIds as any\n                );\n            }\n        }\n    }\n    protected applyFindOptionsOrmOptions(findOptions: FindOptions<Entity>) {\n        if (this.expressionMap.mainAlias!.metadata) {\n            // apply caching options\n            if (typeof findOptions.cache === \"number\") {\n                this.cache(findOptions.cache);\n            } else if (typeof findOptions.cache === \"boolean\") {\n                this.cache(findOptions.cache);\n            } else if (typeof findOptions.cache === \"object\") {\n                this.cache(\n                    findOptions.cache.id,\n                    findOptions.cache.milliseconds\n                );\n            }\n\n            if (findOptions.options) {\n                if (findOptions.options.listeners === false)\n                    this.callListeners(false);\n\n                if (findOptions.options.observers === false)\n                    this.callObservers(false);\n            }\n            if (findOptions.lock) {\n                if (findOptions.lock.mode === \"optimistic\") {\n                    this.setLock(\n                        findOptions.lock.mode,\n                        findOptions.lock.version\n                    );\n                } else {\n                    this.setLock(findOptions.lock.mode);\n                }\n            }\n\n            if (\n                findOptions.options &&\n                findOptions.options.eagerRelations !== undefined\n            ) {\n                this.expressionMap.eagerRelations =\n                    findOptions.options.eagerRelations;\n            }\n        }\n    }\n\n    protected async executeCountQuery(\n        queryRunner: QueryRunner\n    ): Promise<number> {\n        const mainAlias = this.expressionMap.mainAlias!.name; // todo: will this work with \"fromTableName\"?\n        const metadata = this.expressionMap.mainAlias!.metadata;\n\n        const distinctAlias = this.escape(mainAlias);\n        let countSql: string = \"\";\n        if (metadata.hasMultiplePrimaryKeys) {\n            if (this.connection.driver instanceof AbstractSqliteDriver) {\n                countSql =\n                    `COUNT(DISTINCT(` +\n                    metadata.primaryColumns\n                        .map((primaryColumn, index) => {\n                            const propertyName = this.escape(\n                                primaryColumn.databaseName\n                            );\n                            return `${distinctAlias}.${propertyName}`;\n                        })\n                        .join(\" || \") +\n                    \")) as \\\"cnt\\\"\";\n            } else {\n                countSql =\n                    `COUNT(DISTINCT(CONCAT(` +\n                    metadata.primaryColumns\n                        .map((primaryColumn, index) => {\n                            const propertyName = this.escape(\n                                primaryColumn.databaseName\n                            );\n                            return `${distinctAlias}.${propertyName}`;\n                        })\n                        .join(\", \") +\n                    \"))) as \\\"cnt\\\"\";\n            }\n        } else {\n            countSql =\n                `COUNT(DISTINCT(` +\n                metadata.primaryColumns\n                    .map((primaryColumn, index) => {\n                        const propertyName = this.escape(\n                            primaryColumn.databaseName\n                        );\n                        return `${distinctAlias}.${propertyName}`;\n                    })\n                    .join(\", \") +\n                \")) as \\\"cnt\\\"\";\n        }\n\n        const results = await this.clone()\n            .orderBy()\n            .groupBy()\n            .offset(undefined)\n            .limit(undefined)\n            .skip(undefined)\n            .take(undefined)\n            .select(countSql)\n            .setOption(\"disable-global-order\")\n            // .setFindOptions({ where: this.findOptions.where })\n            .loadRawResults(queryRunner);\n\n        if (!results || !results[0] || !results[0][\"cnt\"]) return 0;\n\n        return parseInt(results[0][\"cnt\"]);\n    }\n\n    /**\n     * Executes sql generated by query builder and returns object with raw results and entities created from them.\n     */\n    protected async executeEntitiesAndRawResults(\n        queryRunner: QueryRunner\n    ): Promise<{ entities: Entity[]; raw: any[] }> {\n        if (!this.expressionMap.mainAlias)\n            throw new Error(\n                `Alias is not set. Use \"from\" method to set an alias.`\n            );\n\n        const cloneQb1 = this.clone();\n        const cloneQb2 = this.clone();\n\n        if (\n            (this.expressionMap.lockMode === \"pessimistic_read\" ||\n                this.expressionMap.lockMode === \"pessimistic_write\") &&\n            !queryRunner.isTransactionActive\n        )\n            throw new PessimisticLockTransactionRequiredError();\n\n        if (this.expressionMap.lockMode === \"optimistic\") {\n            const metadata = this.expressionMap.mainAlias.metadata;\n            if (!metadata.versionColumn && !metadata.updateDateColumn)\n                throw new NoVersionOrUpdateDateColumnError(metadata.name);\n        }\n\n        const relationIdLoader = new RelationIdLoader(\n            this.connection,\n            queryRunner,\n            this.expressionMap.relationIdAttributes\n        );\n        const relationCountLoader = new RelationCountLoader(\n            this.connection,\n            queryRunner,\n            this.expressionMap.relationCountAttributes\n        );\n        const relationIdMetadataTransformer = new RelationIdMetadataToAttributeTransformer(\n            this.expressionMap\n        );\n        relationIdMetadataTransformer.transform();\n        const relationCountMetadataTransformer = new RelationCountMetadataToAttributeTransformer(\n            this.expressionMap\n        );\n        relationCountMetadataTransformer.transform();\n\n        let rawResults: any[] = [],\n            entities: any[] = [];\n\n        // for pagination enabled (e.g. skip and take) its much more complicated - its a special process\n        // where we make two queries to find the data we need\n        // first query find ids in skip and take range\n        // and second query loads the actual data in given ids range\n        if (\n            (this.expressionMap.skip || this.expressionMap.take) &&\n            this.expressionMap.joinAttributes.length > 0\n        ) {\n            // we are skipping order by here because its not working in subqueries anyway\n            // to make order by working we need to apply it on a distinct query\n            const [\n                selects,\n                orderBys\n            ] = this.createOrderByCombinedWithSelectExpression(\"distinctAlias\");\n            const metadata = this.expressionMap.mainAlias.metadata;\n            const mainAliasName = this.expressionMap.mainAlias.name;\n\n            const querySelects = metadata.primaryColumns.map(primaryColumn => {\n                const distinctAlias = this.escape(\"distinctAlias\");\n                const columnAlias = this.escape(\n                    DriverUtils.buildColumnAlias(\n                        this.connection.driver,\n                        mainAliasName,\n                        primaryColumn.databaseName,\n                        { extraNeededLength: 4 }\n                    )\n                );\n                if (!orderBys[columnAlias])\n                    // make sure we aren't overriding user-defined order in inverse direction\n                    orderBys[columnAlias] = \"ASC\";\n                return `${distinctAlias}.${columnAlias} as \"ids_${DriverUtils.buildColumnAlias(\n                    this.connection.driver,\n                    mainAliasName,\n                    primaryColumn.databaseName,\n                    { extraNeededLength: 4 }\n                )}\"`;\n            });\n\n            const clonnedQb = cloneQb1\n                // .setFindOptions({\n                //     select: this.findOptions.select,\n                //     relations: this.findOptions.relations,\n                //     options: this.findOptions.options,\n                //     where: this.findOptions.where\n                // })\n                .orderBy();\n\n            rawResults = await new SelectQueryBuilder(\n                this.connection,\n                queryRunner\n            )\n                .select(`DISTINCT ${querySelects.join(\", \")}`)\n                .addSelect(selects)\n                .from(`(${clonnedQb.getQuery()})`, \"distinctAlias\")\n                .offset(this.expressionMap.skip)\n                .limit(this.expressionMap.take)\n                .orderBy(orderBys)\n                .cache(\n                    this.expressionMap.cache\n                        ? this.expressionMap.cache\n                        : this.expressionMap.cacheId,\n                    this.expressionMap.cacheDuration\n                )\n                .setParameters(this.getParameters())\n                .setNativeParameters(this.expressionMap.nativeParameters)\n                .getRawMany();\n\n            if (rawResults.length > 0) {\n                let condition = \"\";\n                const parameters: ObjectLiteral = {};\n                if (metadata.hasMultiplePrimaryKeys) {\n                    condition = rawResults\n                        .map((result, index) => {\n                            return metadata.primaryColumns\n                                .map(primaryColumn => {\n                                    parameters[\n                                        `ids_${index}_${primaryColumn.databaseName}`\n                                    ] =\n                                        result[\n                                            `ids_${mainAliasName}_${primaryColumn.databaseName}`\n                                        ];\n                                    return `${mainAliasName}.${primaryColumn.propertyPath}=:ids_${index}_${primaryColumn.databaseName}`;\n                                })\n                                .join(\" AND \");\n                        })\n                        .join(\" OR \");\n                } else {\n                    const ids = rawResults.map(\n                        result =>\n                            result[\n                                \"ids_\" +\n                                    DriverUtils.buildColumnAlias(\n                                        this.connection.driver,\n                                        mainAliasName,\n                                        metadata.primaryColumns[0].databaseName,\n                                        { extraNeededLength: 4 }\n                                    )\n                            ]\n                    );\n                    const areAllNumbers = ids.every(\n                        (id: any) => typeof id === \"number\"\n                    );\n                    const paramAndValues = DriverUtils.buildParamAndValuesForInClause(\n                        this.connection.driver,\n                        `${mainAliasName}.${metadata.primaryColumns[0].propertyPath}`,\n                        ids\n                    );\n                    if (areAllNumbers) {\n                        // fixes #190. if all numbers then its safe to perform query without parameter\n                        condition = `${\n                            paramAndValues.param\n                        } IN (${paramAndValues.values.join(\", \")})`;\n                    } else {\n                        parameters[\"ids\"] = paramAndValues.values;\n                        condition = paramAndValues.param + \" IN (:...ids)\";\n                    }\n                }\n                rawResults = await cloneQb2\n                    // .setFindOptions(this.findOptions)\n                    .mergeExpressionMap({\n                        extraAppendedAndWhereCondition: condition\n                    })\n                    .setParameters(parameters)\n                    .loadRawResults(queryRunner);\n            }\n        } else {\n            // console.time(\"load raw results\");\n            rawResults = await this.loadRawResults(queryRunner);\n            // console.timeEnd(\"load raw results\");\n        }\n\n        if (rawResults.length > 0) {\n            // transform raw results into entities\n            const rawRelationIdResults = await relationIdLoader.load(\n                rawResults\n            );\n            const rawRelationCountResults = await relationCountLoader.load(\n                rawResults\n            );\n            const transformer = new RawSqlResultsToEntityTransformer(\n                this.expressionMap,\n                this.connection.driver,\n                rawRelationIdResults,\n                rawRelationCountResults,\n                this.queryRunner\n            );\n            // console.time(\"transforming entities\");\n            entities = transformer.transform(\n                rawResults,\n                this.expressionMap.mainAlias!\n            );\n            // console.timeEnd(\"transforming entities\");\n\n            // broadcast all \"after load\" events\n            if (\n                this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias.hasMetadata\n            ) {\n                const broadcastResult = new BroadcasterResult();\n                queryRunner.broadcaster.broadcastLoadEventsForAll(\n                    broadcastResult,\n                    this.expressionMap.mainAlias.metadata,\n                    entities\n                );\n                if (broadcastResult.promises.length > 0)\n                    await Promise.all(broadcastResult.promises);\n            }\n        }\n\n        await Promise.all(\n            this.relationMetadatas.map(async relation => {\n                const relationTarget = relation.inverseEntityMetadata.target;\n                const relationAlias = relation.inverseEntityMetadata.targetName;\n\n                const queryBuilder = this.createQueryBuilder()\n                    .select(relationAlias)\n                    .from(relationTarget, relationAlias)\n                    .setFindOptions({\n                        select:\n                            this.findOptions.select &&\n                            typeof this.findOptions.select === \"object\"\n                                ? OrmUtils.deepValue(\n                                      this.findOptions.select,\n                                      relation.propertyPath\n                                  )\n                                : undefined,\n                        order: this.findOptions.order\n                            ? OrmUtils.deepValue(\n                                  this.findOptions.order,\n                                  relation.propertyPath\n                              )\n                            : undefined,\n                        relations:\n                            this.findOptions.relations &&\n                            typeof this.findOptions.relations === \"object\"\n                                ? OrmUtils.deepValue(\n                                      this.findOptions.relations,\n                                      relation.propertyPath\n                                  )\n                                : undefined\n                    });\n                if (entities.length > 0) {\n                    const relatedEntityGroups: any[] = await this.connection.relationIdLoader.loadManyToManyRelationIdsAndGroup(\n                        relation,\n                        entities,\n                        undefined,\n                        queryBuilder\n                    );\n                    entities.forEach(entity => {\n                        const relatedEntityGroup = relatedEntityGroups.find(\n                            group => group.entity === entity\n                        );\n                        if (relatedEntityGroup) {\n                            const value =\n                                relatedEntityGroup.related === undefined\n                                    ? null\n                                    : relatedEntityGroup.related;\n                            relation.setEntityValue(entity, value);\n                        }\n                    });\n                }\n            })\n        );\n\n        return {\n            raw: rawResults,\n            entities: entities\n        };\n    }\n\n    protected createOrderByCombinedWithSelectExpression(\n        parentAlias: string\n    ): [string, OrderByCondition] {\n        // if table has a default order then apply it\n        const orderBys = this.expressionMap.allOrderBys;\n        const selectString = Object.keys(orderBys)\n            .map(orderCriteria => {\n                if (orderCriteria.indexOf(\".\") !== -1) {\n                    const [\n                        aliasName,\n                        propertyPath\n                    ] = QueryBuilderUtils.extractAliasAndPropertyPath(\n                        orderCriteria\n                    );\n                    const alias = this.expressionMap.findAliasByName(aliasName);\n                    const column = alias.metadata.findColumnWithPropertyPath(\n                        propertyPath\n                    );\n                    return (\n                        this.escape(parentAlias) +\n                        \".\" +\n                        this.escape(\n                            DriverUtils.buildColumnAlias(\n                                this.connection.driver,\n                                aliasName,\n                                column!.databaseName\n                            )\n                        )\n                    );\n                } else {\n                    if (\n                        this.expressionMap.selects.find(\n                            select =>\n                                select.selection === orderCriteria ||\n                                select.aliasName === orderCriteria\n                        )\n                    )\n                        return this.escape(parentAlias) + \".\" + orderCriteria;\n\n                    return \"\";\n                }\n            })\n            .join(\", \");\n\n        const orderByObject: OrderByCondition = {};\n        Object.keys(orderBys).forEach(orderCriteria => {\n            if (orderCriteria.indexOf(\".\") !== -1) {\n                const [\n                    aliasName,\n                    propertyPath\n                ] = QueryBuilderUtils.extractAliasAndPropertyPath(\n                    orderCriteria\n                );\n                const alias = this.expressionMap.findAliasByName(aliasName);\n                const column = alias.metadata.findColumnWithPropertyPath(\n                    propertyPath\n                );\n                orderByObject[\n                    this.escape(parentAlias) +\n                        \".\" +\n                        this.escape(\n                            DriverUtils.buildColumnAlias(\n                                this.connection.driver,\n                                aliasName,\n                                column!.databaseName\n                            )\n                        )\n                ] = orderBys[orderCriteria];\n            } else {\n                if (\n                    this.expressionMap.selects.find(\n                        select =>\n                            select.selection === orderCriteria ||\n                            select.aliasName === orderCriteria\n                    )\n                ) {\n                    orderByObject[\n                        this.escape(parentAlias) + \".\" + orderCriteria\n                    ] = orderBys[orderCriteria];\n                } else {\n                    orderByObject[orderCriteria] = orderBys[orderCriteria];\n                }\n            }\n        });\n\n        return [selectString, orderByObject];\n    }\n\n    /**\n     * Loads raw results from the database.\n     */\n    protected async loadRawResults(queryRunner: QueryRunner) {\n        const [sql, parameters] = this.getQueryAndParameters();\n        const queryId = sql + \" -- PARAMETERS: \" + JSON.stringify(parameters);\n        const cacheOptions =\n            typeof this.connection.options.cache === \"object\"\n                ? this.connection.options.cache\n                : {};\n        let savedQueryResultCacheOptions:\n            | QueryResultCacheOptions\n            | undefined = undefined;\n        if (\n            this.connection.queryResultCache &&\n            (this.expressionMap.cache || cacheOptions.alwaysEnabled)\n        ) {\n            savedQueryResultCacheOptions = await this.connection.queryResultCache.getFromCache(\n                {\n                    identifier: this.expressionMap.cacheId,\n                    query: queryId,\n                    duration:\n                        this.expressionMap.cacheDuration ||\n                        cacheOptions.duration ||\n                        1000\n                },\n                queryRunner\n            );\n            if (\n                savedQueryResultCacheOptions &&\n                !this.connection.queryResultCache.isExpired(\n                    savedQueryResultCacheOptions\n                )\n            )\n                return JSON.parse(savedQueryResultCacheOptions.result);\n        }\n\n        const results = await queryRunner.query(sql, parameters);\n\n        if (\n            this.connection.queryResultCache &&\n            (this.expressionMap.cache || cacheOptions.alwaysEnabled)\n        ) {\n            await this.connection.queryResultCache.storeInCache(\n                {\n                    identifier: this.expressionMap.cacheId,\n                    query: queryId,\n                    time: new Date().getTime(),\n                    duration:\n                        this.expressionMap.cacheDuration ||\n                        cacheOptions.duration ||\n                        1000,\n                    result: JSON.stringify(results)\n                },\n                savedQueryResultCacheOptions,\n                queryRunner\n            );\n        }\n\n        return results;\n    }\n\n    /**\n     * Merges into expression map given expression map properties.\n     */\n    protected mergeExpressionMap(\n        expressionMap: Partial<QueryExpressionMap>\n    ): this {\n        ObjectUtils.assign(this.expressionMap, expressionMap);\n        return this;\n    }\n\n    /**\n     * Normalizes a give number - converts to int if possible.\n     */\n    protected normalizeNumber(num: any) {\n        if (typeof num === \"number\" || num === undefined || num === null)\n            return num;\n\n        return Number(num);\n    }\n\n    /**\n     * Creates a query builder used to execute sql queries inside this query builder.\n     */\n    protected obtainQueryRunner() {\n        return this.queryRunner || this.connection.createQueryRunner(\"slave\");\n    }\n\n    protected buildSelect(\n        select: FindOptionsSelect<any>,\n        metadata: EntityMetadata,\n        alias: string,\n        embedPrefix?: string\n    ) {\n        if (Array.isArray(select)) {\n            select.forEach(select => {\n                this.selects.push(\n                    this.expressionMap.mainAlias!.name +\n                        \".\" +\n                        (select as string)\n                );\n            });\n        } else {\n            for (let key in select) {\n                if (select[key] === undefined) continue;\n\n                const propertyPath = embedPrefix\n                    ? embedPrefix + \".\" + key\n                    : key;\n                const column = metadata.findColumnWithPropertyPathStrict(\n                    propertyPath\n                );\n                const embed = metadata.findEmbeddedWithPropertyPath(\n                    propertyPath\n                );\n                const relation = metadata.findRelationWithPropertyPath(\n                    propertyPath\n                );\n\n                if (!embed && !column && !relation)\n                    throw new FindCriteriaNotFoundError(propertyPath, metadata);\n\n                if (column) {\n                    this.selects.push(alias + \".\" + propertyPath);\n                } else if (embed) {\n                    this.buildSelect(\n                        select[key] as FindOptionsOrder<any>,\n                        metadata,\n                        alias,\n                        propertyPath\n                    );\n\n                    // } else if (relation) {\n                    //     const joinAlias = alias + \"_\" + relation.propertyName;\n                    //     const existJoin = this.joins.find(join => join.alias === joinAlias);\n                    //     if (!existJoin) {\n                    //         this.joins.push({\n                    //             type: \"left\",\n                    //             select: false,\n                    //             alias: joinAlias,\n                    //             parentAlias: alias,\n                    //             relationMetadata: relation\n                    //         });\n                    //     }\n                    //     this.buildOrder(select[key] as FindOptionsOrder<any>, relation.inverseEntityMetadata, joinAlias);\n                }\n            }\n        }\n    }\n\n    protected buildRelations(\n        relations: FindOptionsRelation<any> | any,\n        metadata: EntityMetadata,\n        embedPrefix?: string\n    ) {\n        if (!relations) return;\n\n        if (Array.isArray(relations)) {\n            relations.forEach(relationName => {\n                const propertyPath = embedPrefix\n                    ? embedPrefix + \".\" + relationName\n                    : relationName;\n                const relation = metadata.findRelationWithPropertyPath(\n                    propertyPath\n                );\n                if (!relation)\n                    throw new FindCriteriaNotFoundError(propertyPath, metadata);\n\n                this.relationMetadatas.push(relation);\n            });\n        } else {\n            Object.keys(relations).forEach(relationName => {\n                const relationValue = (relations as any)[relationName];\n                if (relationValue === true || relationValue instanceof Object) {\n                    const propertyPath = embedPrefix\n                        ? embedPrefix + \".\" + relationName\n                        : relationName;\n                    const embed = metadata.findEmbeddedWithPropertyPath(\n                        propertyPath\n                    );\n                    const relation = metadata.findRelationWithPropertyPath(\n                        propertyPath\n                    );\n                    if (!embed && !relation)\n                        throw new FindCriteriaNotFoundError(\n                            propertyPath,\n                            metadata\n                        );\n\n                    if (embed) {\n                        this.buildRelations(\n                            relationValue as FindOptionsRelation<any>,\n                            metadata,\n                            propertyPath\n                        );\n                    } else {\n                        this.relationMetadatas.push(relation!);\n                    }\n                }\n            });\n        }\n    }\n\n    protected buildOrder(\n        order: FindOptionsOrder<any>,\n        metadata: EntityMetadata,\n        alias: string,\n        embedPrefix?: string\n    ) {\n        for (let key in order) {\n            if (order[key] === undefined) continue;\n\n            const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key;\n            const column = metadata.findColumnWithPropertyPathStrict(\n                propertyPath\n            );\n            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);\n            const relation = metadata.findRelationWithPropertyPath(\n                propertyPath\n            );\n\n            if (!embed && !column && !relation)\n                throw new FindCriteriaNotFoundError(propertyPath, metadata);\n\n            if (column) {\n                let direction =\n                    order[key] instanceof Object\n                        ? (order[key] as any).direction\n                        : order[key];\n                direction =\n                    direction === \"DESC\" ||\n                    direction === \"desc\" ||\n                    direction === -1\n                        ? \"DESC\"\n                        : \"ASC\";\n                let nulls =\n                    order[key] instanceof Object\n                        ? (order[key] as any).nulls\n                        : undefined;\n                nulls =\n                    nulls === \"first\"\n                        ? \"NULLS FIRST\"\n                        : nulls === \"last\"\n                        ? \"NULLS LAST\"\n                        : undefined;\n\n                this.orderBys.push({\n                    alias: alias + \".\" + propertyPath,\n                    direction,\n                    nulls\n                }); // `${alias}.${propertyPath} = :${paramName}`);\n            } else if (embed) {\n                this.buildOrder(\n                    order[key] as FindOptionsOrder<any>,\n                    metadata,\n                    alias,\n                    propertyPath\n                );\n            } else if (relation) {\n                // Hack Julien (Fix the parameter too long issue we have on oracle (limit is 30)\n                // const joinAlias = alias + \"_\" + relation.propertyName;\n                const joinAlias = DriverUtils.buildColumnAlias(\n                    this.connection.driver,\n                    alias,\n                    relation.propertyName\n                );\n                const existJoin = this.joins.find(\n                    join => join.alias === joinAlias\n                );\n                if (!existJoin) {\n                    this.joins.push({\n                        type: \"left\",\n                        select: false,\n                        alias: joinAlias,\n                        parentAlias: alias,\n                        relationMetadata: relation\n                    });\n                }\n                this.buildOrder(\n                    order[key] as FindOptionsOrder<any>,\n                    relation.inverseEntityMetadata,\n                    joinAlias\n                );\n            }\n        }\n    }\n\n    protected buildWhere(\n        where: any,\n        metadata: EntityMetadata,\n        alias: string,\n        embedPrefix?: string\n    ): string {\n        let condition: string = \"\";\n        let parameterIndex = Object.keys(this.expressionMap.nativeParameters)\n            .length;\n        if (Array.isArray(where)) {\n            condition =\n                \"(\" +\n                where\n                    .map(whereItem => {\n                        return this.buildWhere(\n                            whereItem,\n                            metadata,\n                            alias,\n                            embedPrefix\n                        );\n                    })\n                    .filter(condition => !!condition)\n                    .map(condition => \"(\" + condition + \")\")\n                    .join(\" OR \") +\n                \")\";\n        } else {\n            let andConditions: string[] = [];\n            for (let key in where) {\n                if (where[key] === undefined) continue;\n\n                const propertyPath = embedPrefix\n                    ? embedPrefix + \".\" + key\n                    : key;\n                const column = metadata.findColumnWithPropertyPathStrict(\n                    propertyPath\n                );\n                const embed = metadata.findEmbeddedWithPropertyPath(\n                    propertyPath\n                );\n                const relation = metadata.findRelationWithPropertyPath(\n                    propertyPath\n                );\n\n                if (!embed && !column && !relation)\n                    throw new FindCriteriaNotFoundError(propertyPath, metadata);\n\n                if (column) {\n                    const aliasPath = `${alias}.${propertyPath}`;\n\n                    const parameterValue = column.transformer\n                        ? ApplyValueTransformers.transformTo(\n                              column.transformer,\n                              where[key]\n                          )\n                        : where[key];\n\n                    if (parameterValue === null) {\n                        andConditions.push(`${aliasPath} IS NULL`);\n                    } else if (parameterValue instanceof FindOperator) {\n                        let parameters: any[] = [];\n                        if (parameterValue.useParameter) {\n                            const realParameterValues: any[] = parameterValue.multipleParameters\n                                ? parameterValue.value\n                                : [parameterValue.value];\n                            // Hack Julien (Fix the parameter too long issue we have on oracle (limit is 30)\n                            // const parameterName = alias + \"_\" + propertyPath.split(\".\").join(\"_\") + \"_\" + parameterIndex;\n                            const extraNeededLength = `${realParameterValues.length}`\n                                .length;\n                            const parameterName = DriverUtils.buildColumnAlias(\n                                this.connection.driver,\n                                alias,\n                                propertyPath.split(\".\").join(\"_\") +\n                                    \"_\" +\n                                    parameterIndex,\n                                { extraNeededLength }\n                            );\n\n                            realParameterValues.forEach(\n                                (\n                                    realParameterValue,\n                                    realParameterValueIndex\n                                ) => {\n                                    // don't create parameters for number to prevent max number of variables issues as much as possible\n                                    if (\n                                        typeof realParameterValue === \"number\"\n                                    ) {\n                                        parameters.push(realParameterValue);\n                                    } else {\n                                        this.expressionMap.nativeParameters[\n                                            parameterName +\n                                                realParameterValueIndex\n                                        ] = realParameterValue;\n                                        parameterIndex++;\n                                        parameters.push(\n                                            this.connection.driver.createParameter(\n                                                parameterName +\n                                                    realParameterValueIndex,\n                                                parameterIndex - 1\n                                            )\n                                        );\n                                    }\n                                }\n                            );\n                        }\n                        andConditions.push(\n                            parameterValue.toSql(\n                                this.connection,\n                                aliasPath,\n                                parameters\n                            )\n                        );\n                    } else {\n                        // Hack Julien (Fix the parameter too long issue we have on oracle (limit is 30)\n                        // const parameterName = alias + \"_\" + propertyPath.split(\".\").join(\"_\") + \"_\" + parameterIndex;\n                        const parameterName2 = DriverUtils.buildColumnAlias(\n                            this.connection.driver,\n                            alias,\n                            propertyPath.split(\".\").join(\"_\") +\n                                \"_\" +\n                                parameterIndex\n                        );\n\n                        this.expressionMap.nativeParameters[\n                            parameterName2\n                        ] = parameterValue;\n                        parameterIndex++;\n                        const parameter = this.connection.driver.createParameter(\n                            parameterName2,\n                            parameterIndex - 1\n                        );\n                        andConditions.push(`${aliasPath} = ${parameter}`);\n                    }\n\n                    // this.conditions.push(`${alias}.${propertyPath} = :${paramName}`);\n                    // this.expressionMap.parameters[paramName] = where[key]; // todo: handle functions and other edge cases\n                } else if (embed) {\n                    const condition = this.buildWhere(\n                        where[key],\n                        metadata,\n                        alias,\n                        propertyPath\n                    );\n                    if (condition) andConditions.push(condition);\n                } else if (relation) {\n                    // if all properties of where are undefined we don't need to join anything\n                    // this can happen when user defines map with conditional queries inside\n                    if (where[key] instanceof Object) {\n                        const allAllUndefined = Object.keys(where[key]).every(\n                            k => where[key][k] === undefined\n                        );\n                        if (allAllUndefined) {\n                            continue;\n                        }\n                    }\n\n                    if (where[key] instanceof FindOperator) {\n                        if (\n                            where[key].type === \"moreThan\" ||\n                            where[key].type === \"lessThan\"\n                        ) {\n                            const sqlOperator =\n                                where[key].type === \"moreThan\" ? \">\" : \"<\";\n                            // basically relation count functionality\n                            const qb: QueryBuilder<any> = this.subQuery();\n                            if (relation.isManyToManyOwner) {\n                                qb.select(\"COUNT(*)\")\n                                    .from(\n                                        relation.joinTableName,\n                                        relation.joinTableName\n                                    )\n                                    .where(\n                                        relation.joinColumns\n                                            .map(column => {\n                                                return `${\n                                                    relation.joinTableName\n                                                }.${\n                                                    column.propertyName\n                                                } = ${alias}.${\n                                                    column.referencedColumn!\n                                                        .propertyName\n                                                }`;\n                                            })\n                                            .join(\" AND \")\n                                    );\n                            } else if (relation.isManyToManyNotOwner) {\n                                qb.select(\"COUNT(*)\")\n                                    .from(\n                                        relation.inverseRelation!.joinTableName,\n                                        relation.inverseRelation!.joinTableName\n                                    )\n                                    .where(\n                                        relation\n                                            .inverseRelation!.inverseJoinColumns.map(\n                                                column => {\n                                                    return `${\n                                                        relation.inverseRelation!\n                                                            .joinTableName\n                                                    }.${\n                                                        column.propertyName\n                                                    } = ${alias}.${\n                                                        column.referencedColumn!\n                                                            .propertyName\n                                                    }`;\n                                                }\n                                            )\n                                            .join(\" AND \")\n                                    );\n                            } else if (relation.isOneToMany) {\n                                qb.select(\"COUNT(*)\")\n                                    .from(\n                                        relation.inverseEntityMetadata.target,\n                                        relation.inverseEntityMetadata.tableName\n                                    )\n                                    .where(\n                                        relation\n                                            .inverseRelation!.joinColumns.map(\n                                                column => {\n                                                    return `${\n                                                        relation\n                                                            .inverseEntityMetadata\n                                                            .tableName\n                                                    }.${\n                                                        column.propertyName\n                                                    } = ${alias}.${\n                                                        column.referencedColumn!\n                                                            .propertyName\n                                                    }`;\n                                                }\n                                            )\n                                            .join(\" AND \")\n                                    );\n                            } else {\n                                throw new Error(\n                                    `This relation isn't supported by given find operator`\n                                );\n                            }\n                            // this\n                            //     .addSelect(qb.getSql(), relation.propertyAliasName + \"_cnt\")\n                            //     .andWhere(this.escape(relation.propertyAliasName + \"_cnt\") + \" \" + sqlOperator + \" \" + parseInt(where[key].value));\n                            this.andWhere(\n                                qb.getSql() +\n                                    \" \" +\n                                    sqlOperator +\n                                    \" \" +\n                                    parseInt(where[key].value)\n                            );\n                        }\n                    } else {\n                        // Hack Julien (Fix the parameter too long issue we have on oracle (limit is 30)\n                        // const joinAlias = alias + \"_\" + relation.propertyName;\n                        const joinAlias = DriverUtils.buildColumnAlias(\n                            this.connection.driver,\n                            alias,\n                            relation.propertyName\n                        );\n                        const existJoin = this.joins.find(\n                            join => join.alias === joinAlias\n                        );\n                        if (!existJoin) {\n                            this.joins.push({\n                                type: \"inner\",\n                                select: false,\n                                alias: joinAlias,\n                                parentAlias: alias,\n                                relationMetadata: relation\n                            });\n                        } else {\n                            if (existJoin.type === \"left\")\n                                existJoin.type = \"inner\";\n                        }\n\n                        const condition = this.buildWhere(\n                            where[key],\n                            relation.inverseEntityMetadata,\n                            joinAlias\n                        );\n                        if (condition) andConditions.push(condition);\n                    }\n                }\n            }\n            condition = andConditions.join(\" AND \");\n        }\n        return condition;\n    }\n}\n"],"sourceRoot":".."}