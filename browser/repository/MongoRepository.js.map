{"version":3,"sources":["../browser/src/repository/MongoRepository.ts"],"names":[],"mappings":"","file":"MongoRepository.js","sourcesContent":["import {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {Repository} from \"./Repository\";\nimport {\n    AggregationCursor,\n    BulkWriteOpResultObject,\n    Code,\n    Collection,\n    CollectionAggregationOptions,\n    CollectionBulkWriteOptions,\n    CollectionInsertManyOptions,\n    CollectionInsertOneOptions,\n    CollectionOptions,\n    CollStats,\n    CommandCursor,\n    Cursor,\n    DeleteWriteOpResultObject,\n    FindAndModifyWriteOpResultObject,\n    FindOneAndReplaceOption,\n    GeoHaystackSearchOptions,\n    GeoNearOptions,\n    InsertOneWriteOpResult,\n    InsertWriteOpResult,\n    MapReduceOptions,\n    MongoCountPreferences,\n    MongodbIndexOptions, ObjectID,\n    OrderedBulkOperation,\n    ParallelCollectionScanOptions,\n    ReadPreference,\n    ReplaceOneOptions,\n    UnorderedBulkOperation,\n    UpdateWriteOpResult\n} from \"../driver/mongodb/typings\";\nimport {MongoEntityManager} from \"../entity-manager/MongoEntityManager\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\nimport {SelectQueryBuilder} from \"../query-builder/SelectQueryBuilder\";\nimport {FindExtraOptions, FindOptions, FindOptionsWhere} from \"../find-options/FindOptions\";\n\n/**\n * Repository used to manage mongodb documents of a single entity type.\n */\nexport type MongoRepository<Entity extends ObjectLiteral> = Repository<Entity> & {\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Entity Manager used by this repository.\n     */\n    readonly manager: MongoEntityManager;\n\n    // -------------------------------------------------------------------------\n    // Overridden Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Raw SQL query execution is not supported by MongoDB.\n     * Calling this method will return an error.\n     */\n    query(query: string, parameters?: any[]): Promise<any>\n\n    /**\n     * Using Query Builder with MongoDB is not supported yet.\n     * Calling this method will return an error.\n     */\n    createQueryBuilder(alias: string, queryRunner?: QueryRunner): SelectQueryBuilder<Entity>\n\n    /**\n     * Finds entities that match given find options or conditions.\n     */\n    find(optionsOrConditions?: FindOptions<Entity>|FindOptionsWhere<Entity>): Promise<Entity[]>\n\n    /**\n     * Finds entities that match given find options or conditions.\n     * Also counts all entities that match given conditions,\n     * but ignores pagination settings (from and take options).\n     */\n    findAndCount(optionsOrConditions?: FindOptions<Entity>|FindOptionsWhere<Entity>): Promise<[ Entity[], number ]>\n\n    /**\n     * Finds entities by ids.\n     * Optionally find options can be applied.\n     */\n    findByIds(ids: any[], optionsOrConditions?: FindOptions<Entity>|FindOptionsWhere<Entity>): Promise<Entity[]>\n\n    /**\n     * Finds first entity that matches given conditions and/or find options.\n     */\n    findOne(optionsOrConditions?: string|number|Date|ObjectID|FindOptions<Entity>|FindOptionsWhere<Entity>, maybeOptions?: FindOptions<Entity>): Promise<Entity|undefined>\n\n    /**\n     * Creates a cursor for a query that can be used to iterate over results from MongoDB.\n     */\n    createCursor<T = any>(query?: ObjectLiteral): Cursor<T>\n\n    /**\n     * Creates a cursor for a query that can be used to iterate over results from MongoDB.\n     * This returns modified version of cursor that transforms each result into Entity model.\n     */\n    createEntityCursor(query?: ObjectLiteral): Cursor<Entity>\n\n    /**\n     * Execute an aggregation framework pipeline against the collection.\n     */\n    aggregate<R = any>(pipeline: ObjectLiteral[], options?: CollectionAggregationOptions): AggregationCursor<R>\n\n    /**\n     * Execute an aggregation framework pipeline against the collection.\n     * This returns modified version of cursor that transforms each result into Entity model.\n     */\n    aggregateEntity(pipeline: ObjectLiteral[], options?: CollectionAggregationOptions): AggregationCursor<Entity>\n\n    /**\n     * Perform a bulkWrite operation without a fluent API.\n     */\n    bulkWrite(operations: ObjectLiteral[], options?: CollectionBulkWriteOptions): Promise<BulkWriteOpResultObject>\n\n    /**\n     * Count number of matching documents in the db to a query.\n     */\n    count(query?: ObjectLiteral, options?: FindExtraOptions, mongoOptions?: MongoCountPreferences): Promise<number>\n\n    /**\n     * Creates an index on the db and collection.\n     */\n    createCollectionIndex(fieldOrSpec: string|any, options?: MongodbIndexOptions): Promise<string>\n\n    /**\n     * Creates multiple indexes in the collection, this method is only supported for MongoDB 2.6 or higher.\n     * Earlier version of MongoDB will throw a command not supported error.\n     * Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.\n     */\n    createCollectionIndexes(indexSpecs: ObjectLiteral[]): Promise<void>\n\n    /**\n     * Delete multiple documents on MongoDB.\n     */\n    deleteMany(query: ObjectLiteral, options?: CollectionOptions): Promise<DeleteWriteOpResultObject>\n\n    /**\n     * Delete a document on MongoDB.\n     */\n    deleteOne(query: ObjectLiteral, options?: CollectionOptions): Promise<DeleteWriteOpResultObject>\n\n    /**\n     * The distinct command returns returns a list of distinct values for the given key across a collection.\n     */\n    distinct(key: string, query: ObjectLiteral, options?: { readPreference?: ReadPreference|string }): Promise<any>\n\n    /**\n     * Drops an index from this collection.\n     */\n    dropCollectionIndex(indexName: string, options?: CollectionOptions): Promise<any>\n\n    /**\n     * Drops all indexes from the collection.\n     */\n    dropCollectionIndexes(): Promise<any>\n\n    /**\n     * Find a document and delete it in one atomic operation, requires a write lock for the duration of the operation.\n     */\n    findOneAndDelete(query: ObjectLiteral, options?: { projection?: Object, sort?: Object, maxTimeMS?: number }): Promise<FindAndModifyWriteOpResultObject>\n\n    /**\n     * Find a document and replace it in one atomic operation, requires a write lock for the duration of the operation.\n     */\n    findOneAndReplace(query: ObjectLiteral, replacement: Object, options?: FindOneAndReplaceOption): Promise<FindAndModifyWriteOpResultObject>\n\n    /**\n     * Find a document and update it in one atomic operation, requires a write lock for the duration of the operation.\n     */\n    findOneAndUpdate(query: ObjectLiteral, update: Object, options?: FindOneAndReplaceOption): Promise<FindAndModifyWriteOpResultObject>\n\n    /**\n     * Execute a geo search using a geo haystack index on a collection.\n     */\n    geoHaystackSearch(x: number, y: number, options?: GeoHaystackSearchOptions): Promise<any>\n\n    /**\n     * Execute the geoNear command to search for items in the collection.\n     */\n    geoNear(x: number, y: number, options?: GeoNearOptions): Promise<any>\n\n    /**\n     * Run a group command across a collection.\n     */\n    group(keys: Object|Array<any>|Function|Code, condition: Object, initial: Object, reduce: Function|Code, finalize: Function|Code, command: boolean, options?: { readPreference?: ReadPreference | string }): Promise<any>\n\n    /**\n     * Retrieve all the indexes on the collection.\n     */\n    collectionIndexes(): Promise<any>\n\n    /**\n     * Retrieve all the indexes on the collection.\n     */\n    collectionIndexExists(indexes: string|string[]): Promise<boolean>\n\n    /**\n     * Retrieves this collections index info.\n     */\n    collectionIndexInformation(options?: { full: boolean }): Promise<any>\n\n    /**\n     * Initiate an In order bulk write operation, operations will be serially executed in the order they are added, creating a new operation for each switch in types.\n     */\n    initializeOrderedBulkOp(options?: CollectionOptions): OrderedBulkOperation\n\n    /**\n     * Initiate a Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.\n     */\n    initializeUnorderedBulkOp(options?: CollectionOptions): UnorderedBulkOperation\n\n    /**\n     * Inserts an array of documents into MongoDB.\n     */\n    insertMany(docs: ObjectLiteral[], options?: CollectionInsertManyOptions): Promise<InsertWriteOpResult>\n\n    /**\n     * Inserts a single document into MongoDB.\n     */\n    insertOne(doc: ObjectLiteral, options?: CollectionInsertOneOptions): Promise<InsertOneWriteOpResult>\n\n    /**\n     * Returns if the collection is a capped collection.\n     */\n    isCapped(): Promise<any>\n\n    /**\n     * Get the list of all indexes information for the collection.\n     */\n    listCollectionIndexes(options?: { batchSize?: number, readPreference?: ReadPreference|string }): CommandCursor\n\n    /**\n     * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\n     */\n    mapReduce(map: Function|string, reduce: Function|string, options?: MapReduceOptions): Promise<any>\n\n    /**\n     * Return N number of parallel cursors for a collection allowing parallel reading of entire collection.\n     * There are no ordering guarantees for returned results.\n     */\n    parallelCollectionScan(options?: ParallelCollectionScanOptions): Promise<Cursor<Entity>[]>\n\n    /**\n     * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.\n     */\n    reIndex(): Promise<any>\n\n    /**\n     * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.\n     */\n    rename(newName: string, options?: { dropTarget?: boolean }): Promise<Collection<any>>\n\n    /**\n     * Replace a document on MongoDB.\n     */\n    replaceOne(query: ObjectLiteral, doc: ObjectLiteral, options?: ReplaceOneOptions): Promise<UpdateWriteOpResult>\n\n    /**\n     * Get all the collection statistics.\n     */\n    stats(options?: { scale: number }): Promise<CollStats>\n\n    /**\n     * Update multiple documents on MongoDB.\n     */\n    updateMany(query: ObjectLiteral, update: ObjectLiteral, options?: { upsert?: boolean, w?: any, wtimeout?: number, j?: boolean }): Promise<UpdateWriteOpResult>\n\n    /**\n     * Update a single document on MongoDB.\n     */\n    updateOne(query: ObjectLiteral, update: ObjectLiteral, options?: ReplaceOneOptions): Promise<UpdateWriteOpResult>\n\n};\n"],"sourceRoot":".."}