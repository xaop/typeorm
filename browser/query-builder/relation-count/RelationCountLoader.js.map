{"version":3,"sources":["../browser/src/query-builder/relation-count/RelationCountLoader.ts"],"names":[],"mappings":"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","file":"RelationCountLoader.js","sourcesContent":["import { ColumnMetadata } from \"../../metadata/ColumnMetadata\";\nimport { Connection } from \"../../connection/Connection\";\nimport { RelationCountAttribute } from \"./RelationCountAttribute\";\nimport { RelationCountLoadResult } from \"./RelationCountLoadResult\";\nimport { QueryRunner } from \"../../query-runner/QueryRunner\";\nimport { DriverUtils } from \"../../driver/DriverUtils\";\n\nexport class RelationCountLoader {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected connection: Connection,\n        protected queryRunner: QueryRunner | undefined,\n        protected relationCountAttributes: RelationCountAttribute[]\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    async load(rawEntities: any[]): Promise<RelationCountLoadResult[]> {\n        const onlyUnique = (value: any, index: number, self: any) => {\n            return self.indexOf(value) === index;\n        };\n\n        const promises = this.relationCountAttributes.map(\n            async relationCountAttr => {\n                if (relationCountAttr.relation.isOneToMany) {\n                    // example: Post and Category\n                    // loadRelationCountAndMap(\"post.categoryCount\", \"post.categories\")\n                    // we expect it to load array of post ids\n\n                    // todo(dima): fix issues wit multiple primary keys and remove joinColumns[0]\n                    const relation = relationCountAttr.relation; // \"category.posts\"\n                    const inverseRelation = relation.inverseRelation!; // \"post.category\"\n                    const referenceColumnName = inverseRelation.joinColumns[0]\n                        .referencedColumn!.propertyName; // post id\n                    const inverseSideTable =\n                        relation.inverseEntityMetadata.target; // Post\n                    const inverseSideTableName =\n                        relation.inverseEntityMetadata.tableName; // post\n                    const inverseSideTableAlias =\n                        relationCountAttr.alias || inverseSideTableName; // if condition (custom query builder factory) is set then relationIdAttr.alias defined\n                    const inverseSidePropertyName =\n                        inverseRelation.propertyName; // \"category\" from \"post.category\"\n\n                    let referenceColumnValues = rawEntities\n                        .map(\n                            rawEntity =>\n                                rawEntity[\n                                    relationCountAttr.parentAlias +\n                                        \"_\" +\n                                        referenceColumnName\n                                ]\n                        )\n                        .filter(value => !!value);\n                    referenceColumnValues = referenceColumnValues.filter(\n                        onlyUnique\n                    );\n\n                    // ensure we won't perform redundant queries for joined data which was not found in selection\n                    // example: if post.category was not found in db then no need to execute query for category.imageIds\n                    if (referenceColumnValues.length === 0)\n                        return {\n                            relationCountAttribute: relationCountAttr,\n                            results: []\n                        };\n\n                    // generate query:\n                    // SELECT category.post as parentId, COUNT(*) AS cnt FROM category category WHERE category.post IN (1, 2) GROUP BY category.post\n                    const qb = this.connection.createQueryBuilder(\n                        this.queryRunner\n                    );\n                    const paramAndValues = DriverUtils.buildParamAndValuesForInClause(\n                        this.connection.driver,\n                        `${inverseSideTableAlias}.${inverseSidePropertyName}`,\n                        referenceColumnValues\n                    );\n                    qb.select(\n                        inverseSideTableAlias + \".\" + inverseSidePropertyName,\n                        \"parentId\"\n                    )\n                        .addSelect(\"COUNT(*)\", \"cnt\")\n                        .from(inverseSideTable, inverseSideTableAlias)\n                        .where(paramAndValues.param + \" IN (:...ids)\")\n                        .addGroupBy(\n                            inverseSideTableAlias +\n                                \".\" +\n                                inverseSidePropertyName\n                        )\n                        .setParameter(\"ids\", paramAndValues.values);\n\n                    // apply condition (custom query builder factory)\n                    if (relationCountAttr.queryBuilderFactory)\n                        relationCountAttr.queryBuilderFactory(qb);\n\n                    return {\n                        relationCountAttribute: relationCountAttr,\n                        results: await qb.getRawMany()\n                    };\n                } else {\n                    // example: Post and Category\n                    // owner side: loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n                    // inverse side: loadRelationIdAndMap(\"category.postIds\", \"category.posts\")\n                    // we expect it to load array of post ids\n\n                    let joinTableColumnName: string;\n                    let inverseJoinColumnName: string;\n                    let firstJunctionColumn: ColumnMetadata;\n                    let secondJunctionColumn: ColumnMetadata;\n\n                    if (relationCountAttr.relation.isOwning) {\n                        // todo fix joinColumns[0] and inverseJoinColumns[0].\n                        joinTableColumnName = relationCountAttr.relation\n                            .joinColumns[0].referencedColumn!.databaseName;\n                        inverseJoinColumnName = relationCountAttr.relation\n                            .inverseJoinColumns[0].referencedColumn!\n                            .databaseName;\n                        firstJunctionColumn = relationCountAttr.relation\n                            .junctionEntityMetadata!.columns[0];\n                        secondJunctionColumn = relationCountAttr.relation\n                            .junctionEntityMetadata!.columns[1];\n                    } else {\n                        joinTableColumnName = relationCountAttr.relation\n                            .inverseRelation!.inverseJoinColumns[0]\n                            .referencedColumn!.databaseName;\n                        inverseJoinColumnName = relationCountAttr.relation\n                            .inverseRelation!.joinColumns[0].referencedColumn!\n                            .databaseName;\n                        firstJunctionColumn = relationCountAttr.relation\n                            .junctionEntityMetadata!.columns[1];\n                        secondJunctionColumn = relationCountAttr.relation\n                            .junctionEntityMetadata!.columns[0];\n                    }\n\n                    let referenceColumnValues = rawEntities\n                        .map(\n                            rawEntity =>\n                                rawEntity[\n                                    relationCountAttr.parentAlias +\n                                        \"_\" +\n                                        joinTableColumnName\n                                ]\n                        )\n                        .filter(value => !!value);\n                    referenceColumnValues = referenceColumnValues.filter(\n                        onlyUnique\n                    );\n\n                    // ensure we won't perform redundant queries for joined data which was not found in selection\n                    // example: if post.category was not found in db then no need to execute query for category.imageIds\n                    if (referenceColumnValues.length === 0)\n                        return {\n                            relationCountAttribute: relationCountAttr,\n                            results: []\n                        };\n\n                    const junctionAlias = relationCountAttr.junctionAlias;\n                    const inverseSideTableName =\n                        relationCountAttr.joinInverseSideMetadata.tableName;\n                    const inverseSideTableAlias =\n                        relationCountAttr.alias || inverseSideTableName;\n                    const junctionTableName = relationCountAttr.relation\n                        .junctionEntityMetadata!.tableName;\n\n                    const paramAndValues = DriverUtils.buildParamAndValuesForInClause(\n                        this.connection.driver,\n                        `${junctionAlias}.${firstJunctionColumn.propertyName}`,\n                        referenceColumnValues.map(vals =>\n                            isNaN(vals) ? \"'\" + vals + \"'\" : vals\n                        )\n                    );\n                    const condition =\n                        paramAndValues.param +\n                        \" IN (\" +\n                        paramAndValues.values +\n                        \")\" +\n                        \" AND \" +\n                        junctionAlias +\n                        \".\" +\n                        secondJunctionColumn.propertyName +\n                        \" = \" +\n                        inverseSideTableAlias +\n                        \".\" +\n                        inverseJoinColumnName;\n\n                    const qb = this.connection.createQueryBuilder(\n                        this.queryRunner\n                    );\n                    qb.select(\n                        junctionAlias + \".\" + firstJunctionColumn.propertyName,\n                        \"parentId\"\n                    )\n                        .addSelect(\n                            \"COUNT(\" +\n                                qb.escape(inverseSideTableAlias) +\n                                \".\" +\n                                qb.escape(inverseJoinColumnName) +\n                                \")\",\n                            \"cnt\"\n                        )\n                        .from(inverseSideTableName, inverseSideTableAlias)\n                        .innerJoin(junctionTableName, junctionAlias, condition)\n                        .addGroupBy(\n                            junctionAlias +\n                                \".\" +\n                                firstJunctionColumn.propertyName\n                        );\n\n                    // apply condition (custom query builder factory)\n                    if (relationCountAttr.queryBuilderFactory)\n                        relationCountAttr.queryBuilderFactory(qb);\n\n                    return {\n                        relationCountAttribute: relationCountAttr,\n                        results: await qb.getRawMany()\n                    };\n                }\n            }\n        );\n\n        return Promise.all(promises);\n    }\n}\n"],"sourceRoot":"../.."}