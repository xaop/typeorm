{"version":3,"sources":["../browser/src/query-builder/QueryBuilder.ts"],"names":[],"mappings":"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","file":"QueryBuilder.js","sourcesContent":["import { ObjectLiteral } from \"../common/ObjectLiteral\";\nimport { QueryRunner } from \"../query-runner/QueryRunner\";\nimport { Connection } from \"../connection/Connection\";\nimport { QueryExpressionMap } from \"./QueryExpressionMap\";\nimport { SelectQueryBuilder } from \"./SelectQueryBuilder\";\nimport { UpdateQueryBuilder } from \"./UpdateQueryBuilder\";\nimport { DeleteQueryBuilder } from \"./DeleteQueryBuilder\";\nimport { InsertQueryBuilder } from \"./InsertQueryBuilder\";\nimport { RelationQueryBuilder } from \"./RelationQueryBuilder\";\nimport { ObjectType } from \"../common/ObjectType\";\nimport { Alias } from \"./Alias\";\nimport { Brackets } from \"./Brackets\";\nimport { QueryDeepPartialEntity } from \"./QueryPartialEntity\";\nimport { EntityMetadata } from \"../metadata/EntityMetadata\";\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\";\nimport { SqljsDriver } from \"../driver/sqljs/SqljsDriver\";\nimport { SqlServerDriver } from \"../driver/sqlserver/SqlServerDriver\";\nimport { OracleDriver } from \"../driver/oracle/OracleDriver\";\nimport { EntitySchema } from \"../\";\nimport { FindOperator } from \"../find-options/FindOperator\";\nimport { In } from \"../find-options/operator/In\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n\n// todo: completely cover query builder with tests\n// todo: entityOrProperty can be target name. implement proper behaviour if it is.\n// todo: check in persistment if id exist on object and throw exception (can be in partial selection?)\n// todo: fix problem with long aliases eg getMaxIdentifierLength\n// todo: fix replacing in .select(\"COUNT(post.id) AS cnt\") statement\n// todo: implement joinAlways in relations and relationId\n// todo: finish partial selection\n// todo: sugar methods like: .addCount and .selectCount, selectCountAndMap, selectSum, selectSumAndMap, ...\n// todo: implement @Select decorator\n// todo: add select and map functions\n\n// todo: implement relation/entity loading and setting them into properties within a separate query\n// .loadAndMap(\"post.categories\", \"post.categories\", qb => ...)\n// .loadAndMap(\"post.categories\", Category, qb => ...)\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport abstract class QueryBuilder<Entity> {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection on which QueryBuilder was created.\n     */\n    readonly connection: Connection;\n\n    /**\n     * Contains all properties of the QueryBuilder that needs to be build a final query.\n     */\n    readonly expressionMap: QueryExpressionMap;\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Query runner used to execute query builder query.\n     */\n    protected queryRunner?: QueryRunner;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    /**\n     * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\n     */\n    constructor(queryBuilder: QueryBuilder<any>);\n\n    /**\n     * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\n     */\n    constructor(connection: Connection, queryRunner?: QueryRunner);\n\n    /**\n     * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\n     */\n    constructor(\n        connectionOrQueryBuilder: Connection | QueryBuilder<any>,\n        queryRunner?: QueryRunner\n    ) {\n        if (connectionOrQueryBuilder instanceof QueryBuilder) {\n            this.connection = connectionOrQueryBuilder.connection;\n            this.queryRunner = connectionOrQueryBuilder.queryRunner;\n            this.expressionMap = connectionOrQueryBuilder.expressionMap.clone();\n        } else {\n            this.connection = connectionOrQueryBuilder;\n            this.queryRunner = queryRunner;\n            this.expressionMap = new QueryExpressionMap(this.connection);\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Abstract Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated sql query without parameters being replaced.\n     */\n    abstract getQuery(): string;\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets the main alias string used in this query builder.\n     */\n    get alias(): string {\n        if (!this.expressionMap.mainAlias)\n            throw new Error(`Main alias is not set`); // todo: better exception\n\n        return this.expressionMap.mainAlias.name;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates SELECT query.\n     * Replaces all previous selections if they exist.\n     */\n    select(): SelectQueryBuilder<Entity>;\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(\n        selection: string,\n        selectionAliasName?: string\n    ): SelectQueryBuilder<Entity>;\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection: string[]): SelectQueryBuilder<Entity>;\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(\n        selection?: string | string[],\n        selectionAliasName?: string\n    ): SelectQueryBuilder<Entity> {\n        this.expressionMap.queryType = \"select\";\n        if (Array.isArray(selection)) {\n            this.expressionMap.selects = selection.map(selection => ({\n                selection: selection\n            }));\n        } else if (selection) {\n            this.expressionMap.selects = [\n                { selection: selection, aliasName: selectionAliasName }\n            ];\n        }\n\n        // loading it dynamically because of circular issue\n        const SelectQueryBuilderCls = require(\"./SelectQueryBuilder\")\n            .SelectQueryBuilder;\n        if (this instanceof SelectQueryBuilderCls) return this as any;\n\n        return new SelectQueryBuilderCls(this);\n    }\n\n    /**\n     * Creates INSERT query.\n     */\n    insert(): InsertQueryBuilder<Entity> {\n        this.expressionMap.queryType = \"insert\";\n\n        // loading it dynamically because of circular issue\n        const InsertQueryBuilderCls = require(\"./InsertQueryBuilder\")\n            .InsertQueryBuilder;\n        if (this instanceof InsertQueryBuilderCls) return this as any;\n\n        return new InsertQueryBuilderCls(this);\n    }\n\n    /**\n     * Creates UPDATE query and applies given update values.\n     */\n    update(): UpdateQueryBuilder<Entity>;\n\n    /**\n     * Creates UPDATE query and applies given update values.\n     */\n    update(\n        updateSet: QueryDeepPartialEntity<Entity>\n    ): UpdateQueryBuilder<Entity>;\n\n    /**\n     * Creates UPDATE query for the given entity and applies given update values.\n     */\n    update<T>(\n        entity: ObjectType<T>,\n        updateSet?: QueryDeepPartialEntity<T>\n    ): UpdateQueryBuilder<T>;\n\n    /**\n     * Creates UPDATE query for the given entity and applies given update values.\n     */\n    update<T>(\n        entity: EntitySchema<T>,\n        updateSet?: QueryDeepPartialEntity<T>\n    ): UpdateQueryBuilder<T>;\n\n    /**\n     * Creates UPDATE query for the given entity and applies given update values.\n     */\n    update(\n        entity: Function | EntitySchema<Entity> | string,\n        updateSet?: QueryDeepPartialEntity<Entity>\n    ): UpdateQueryBuilder<Entity>;\n\n    /**\n     * Creates UPDATE query for the given table name and applies given update values.\n     */\n    update(\n        tableName: string,\n        updateSet?: QueryDeepPartialEntity<Entity>\n    ): UpdateQueryBuilder<Entity>;\n\n    /**\n     * Creates UPDATE query and applies given update values.\n     */\n    update(\n        entityOrTableNameUpdateSet?:\n            | string\n            | Function\n            | EntitySchema<any>\n            | ObjectLiteral,\n        maybeUpdateSet?: ObjectLiteral\n    ): UpdateQueryBuilder<any> {\n        const updateSet = maybeUpdateSet\n            ? maybeUpdateSet\n            : (entityOrTableNameUpdateSet as ObjectLiteral | undefined);\n        entityOrTableNameUpdateSet =\n            entityOrTableNameUpdateSet instanceof EntitySchema\n                ? entityOrTableNameUpdateSet.options.name\n                : entityOrTableNameUpdateSet;\n\n        if (\n            entityOrTableNameUpdateSet instanceof Function ||\n            typeof entityOrTableNameUpdateSet === \"string\"\n        ) {\n            const mainAlias = this.createFromAlias(entityOrTableNameUpdateSet);\n            this.expressionMap.setMainAlias(mainAlias);\n        }\n\n        this.expressionMap.queryType = \"update\";\n        this.expressionMap.valuesSet = updateSet;\n\n        // loading it dynamically because of circular issue\n        const UpdateQueryBuilderCls = require(\"./UpdateQueryBuilder\")\n            .UpdateQueryBuilder;\n        if (this instanceof UpdateQueryBuilderCls) return this as any;\n\n        return new UpdateQueryBuilderCls(this);\n    }\n\n    /**\n     * Creates DELETE query.\n     */\n    delete(): DeleteQueryBuilder<Entity> {\n        this.expressionMap.queryType = \"delete\";\n\n        // loading it dynamically because of circular issue\n        const DeleteQueryBuilderCls = require(\"./DeleteQueryBuilder\")\n            .DeleteQueryBuilder;\n        if (this instanceof DeleteQueryBuilderCls) return this as any;\n\n        return new DeleteQueryBuilderCls(this);\n    }\n\n    /**\n     * Sets entity's relation with which this query builder gonna work.\n     */\n    relation(propertyPath: string): RelationQueryBuilder<Entity>;\n\n    /**\n     * Sets entity's relation with which this query builder gonna work.\n     */\n    relation<T>(\n        entityTarget: ObjectType<T> | string,\n        propertyPath: string\n    ): RelationQueryBuilder<T>;\n\n    /**\n     * Sets entity's relation with which this query builder gonna work.\n     */\n    relation(\n        entityTargetOrPropertyPath: Function | string,\n        maybePropertyPath?: string\n    ): RelationQueryBuilder<Entity> {\n        const entityTarget =\n            arguments.length === 2 ? entityTargetOrPropertyPath : undefined;\n        const propertyPath =\n            arguments.length === 2\n                ? (maybePropertyPath as string)\n                : (entityTargetOrPropertyPath as string);\n\n        this.expressionMap.queryType = \"relation\";\n        this.expressionMap.relationPropertyPath = propertyPath;\n\n        if (entityTarget) {\n            const mainAlias = this.createFromAlias(entityTarget);\n            this.expressionMap.setMainAlias(mainAlias);\n        }\n\n        // loading it dynamically because of circular issue\n        const RelationQueryBuilderCls = require(\"./RelationQueryBuilder\")\n            .RelationQueryBuilder;\n        if (this instanceof RelationQueryBuilderCls) return this as any;\n\n        return new RelationQueryBuilderCls(this);\n    }\n\n    /**\n     * Checks if given relation exists in the entity.\n     * Returns true if relation exists, false otherwise.\n     *\n     * todo: move this method to manager? or create a shortcut?\n     */\n    hasRelation<T>(target: ObjectType<T> | string, relation: string): boolean;\n\n    /**\n     * Checks if given relations exist in the entity.\n     * Returns true if relation exists, false otherwise.\n     *\n     * todo: move this method to manager? or create a shortcut?\n     */\n    hasRelation<T>(target: ObjectType<T> | string, relation: string[]): boolean;\n\n    /**\n     * Checks if given relation or relations exist in the entity.\n     * Returns true if relation exists, false otherwise.\n     *\n     * todo: move this method to manager? or create a shortcut?\n     */\n    hasRelation<T>(\n        target: ObjectType<T> | string,\n        relation: string | string[]\n    ): boolean {\n        const entityMetadata = this.connection.getMetadata(target);\n        const relations = Array.isArray(relation) ? relation : [relation];\n        return relations.every(relation => {\n            return !!entityMetadata.findRelationWithPropertyPath(relation);\n        });\n    }\n\n    /**\n     * Sets parameter name and its value.\n     */\n    setParameter(key: string, value: any): this {\n        this.expressionMap.parameters[key] = value;\n        return this;\n    }\n\n    /**\n     * Adds all parameters from the given object.\n     */\n    setParameters(parameters: ObjectLiteral): this {\n        // remove function parameters\n        Object.keys(parameters).forEach(key => {\n            if (parameters[key] instanceof Function) {\n                throw new Error(\n                    `Function parameter isn't supported in the parameters. Please check \"${key}\" parameter.`\n                );\n            }\n        });\n\n        // set parent query builder parameters as well in sub-query mode\n        if (this.expressionMap.parentQueryBuilder)\n            this.expressionMap.parentQueryBuilder.setParameters(parameters);\n\n        Object.keys(parameters).forEach(key =>\n            this.setParameter(key, parameters[key])\n        );\n        return this;\n    }\n\n    /**\n     * Adds native parameters from the given object.\n     */\n    setNativeParameters(parameters: ObjectLiteral): this {\n        // set parent query builder parameters as well in sub-query mode\n        if (this.expressionMap.parentQueryBuilder)\n            this.expressionMap.parentQueryBuilder.setNativeParameters(\n                parameters\n            );\n\n        Object.keys(parameters).forEach(key => {\n            this.expressionMap.nativeParameters[key] = parameters[key];\n        });\n        return this;\n    }\n\n    /**\n     * Gets all parameters.\n     */\n    getParameters(): ObjectLiteral {\n        const parameters: ObjectLiteral = Object.assign(\n            {},\n            this.expressionMap.parameters\n        );\n\n        // add discriminator column parameter if it exist\n        if (\n            this.expressionMap.mainAlias &&\n            this.expressionMap.mainAlias.hasMetadata\n        ) {\n            const metadata = this.expressionMap.mainAlias!.metadata;\n            if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {\n                const values = metadata.childEntityMetadatas\n                    .filter(childMetadata => childMetadata.discriminatorColumn)\n                    .map(childMetadata => childMetadata.discriminatorValue);\n                values.push(metadata.discriminatorValue);\n                parameters[\"discriminatorColumnValues\"] = values;\n            }\n        }\n\n        return parameters;\n    }\n\n    /**\n     * Prints sql to stdout using console.log.\n     */\n    printSql(): this {\n        // TODO rename to logSql()\n        const [query, parameters] = this.getQueryAndParameters();\n        this.connection.logger.logQuery(query, parameters);\n        return this;\n    }\n\n    /**\n     * Gets generated sql that will be executed.\n     * Parameters in the query are escaped for the currently used driver.\n     */\n    getSql(): string {\n        return this.getQueryAndParameters()[0];\n    }\n\n    /**\n     * Gets query to be executed with all parameters used in it.\n     */\n    getQueryAndParameters(): [string, any[]] {\n        // this execution order is important because getQuery method generates this.expressionMap.nativeParameters values\n        const query = this.getQuery();\n        const parameters = this.getParameters();\n        return this.connection.driver.escapeQueryWithParameters(\n            query,\n            parameters,\n            this.expressionMap.nativeParameters\n        );\n    }\n\n    /**\n     * Executes sql generated by query builder and returns raw database results.\n     */\n    async execute(): Promise<any> {\n        const [sql, parameters] = this.getQueryAndParameters();\n        const queryRunner = this.obtainQueryRunner();\n        try {\n            return await queryRunner.query(sql, parameters); // await is needed here because we are using finally\n        } finally {\n            if (queryRunner !== this.queryRunner) {\n                // means we created our own query runner\n                await queryRunner.release();\n            }\n            if (this.connection.driver instanceof SqljsDriver) {\n                await this.connection.driver.autoSave();\n            }\n        }\n    }\n\n    /**\n     * Creates a completely new query builder.\n     * Uses same query runner as current QueryBuilder.\n     */\n    createQueryBuilder(): this {\n        return new (this.constructor as any)(this.connection, this.queryRunner);\n    }\n\n    /**\n     * Clones query builder as it is.\n     * Note: it uses new query runner, if you want query builder that uses exactly same query runner,\n     * you can create query builder using its constructor, for example new SelectQueryBuilder(queryBuilder)\n     * where queryBuilder is cloned QueryBuilder.\n     */\n    clone(): this {\n        return new (this.constructor as any)(this);\n    }\n\n    /**\n     * Disables escaping.\n     */\n    disableEscaping(): this {\n        this.expressionMap.disableEscaping = false;\n        return this;\n    }\n\n    /**\n     * Escapes table name, column name or alias name using current database's escaping character.\n     */\n    escape(name: string): string {\n        if (!this.expressionMap.disableEscaping) return name;\n        return this.connection.driver.escape(name);\n    }\n\n    /**\n     * Sets or overrides query builder's QueryRunner.\n     */\n    setQueryRunner(queryRunner: QueryRunner): this {\n        this.queryRunner = queryRunner;\n        return this;\n    }\n\n    /**\n     * Indicates if listeners and subscribers must be called before and after query execution.\n     * Enabled by default.\n     */\n    callListeners(enabled: boolean): this {\n        this.expressionMap.callListeners = enabled;\n        return this;\n    }\n\n    /**\n     * Indicates if observers must be called before and after query execution.\n     * Enabled by default.\n     */\n    callObservers(enabled: boolean): this {\n        this.expressionMap.callObservers = enabled;\n        return this;\n    }\n\n    /**\n     * If set to true the query will be wrapped into a transaction.\n     */\n    useTransaction(enabled: boolean): this {\n        this.expressionMap.useTransaction = enabled;\n        return this;\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets escaped table name with schema name if SqlServer driver used with custom\n     * schema name, otherwise returns escaped table name.\n     */\n    protected getTableName(tablePath: string): string {\n        return tablePath\n            .split(\".\")\n            .map(i => {\n                // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n                if (i === \"\") return i;\n                return this.escape(i);\n            })\n            .join(\".\");\n    }\n\n    /**\n     * Gets name of the table where insert should be performed.\n     */\n    protected getMainTableName(): string {\n        if (!this.expressionMap.mainAlias)\n            throw new Error(\n                `Entity where values should be inserted is not specified. Call \"qb.into(entity)\" method to specify it.`\n            );\n\n        if (this.expressionMap.mainAlias.hasMetadata)\n            return this.expressionMap.mainAlias.metadata.tablePath;\n\n        return this.expressionMap.mainAlias.tablePath!;\n    }\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    protected createFromAlias(\n        entityTarget:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        aliasName?: string\n    ): Alias {\n        // if table has a metadata then find it to properly escape its properties\n        // const metadata = this.connection.entityMetadatas.find(metadata => metadata.tableName === tableName);\n        if (this.connection.hasMetadata(entityTarget)) {\n            const metadata = this.connection.getMetadata(entityTarget);\n\n            return this.expressionMap.createAlias({\n                type: \"from\",\n                name: aliasName,\n                metadata: this.connection.getMetadata(entityTarget),\n                tablePath: metadata.tablePath\n            });\n        } else {\n            let subQuery: string = \"\";\n            if (entityTarget instanceof Function) {\n                const subQueryBuilder: SelectQueryBuilder<any> = (entityTarget as any)(\n                    ((this as any) as SelectQueryBuilder<any>).subQuery()\n                );\n                this.setParameters(subQueryBuilder.getParameters());\n                subQuery = subQueryBuilder.getQuery();\n            } else {\n                subQuery = entityTarget;\n            }\n            const isSubQuery =\n                entityTarget instanceof Function ||\n                (entityTarget.substr(0, 1) === \"(\" &&\n                    entityTarget.substr(-1) === \")\");\n            return this.expressionMap.createAlias({\n                type: \"from\",\n                name: aliasName,\n                tablePath:\n                    isSubQuery === false ? (entityTarget as string) : undefined,\n                subQuery: isSubQuery === true ? subQuery : undefined\n            });\n        }\n    }\n\n    /**\n     * Replaces all entity's propertyName to name in the given statement.\n     */\n    protected replacePropertyNames(statement: string) {\n        this.expressionMap.aliases.forEach(alias => {\n            if (!alias.hasMetadata) return;\n            const replaceAliasNamePrefix = this.expressionMap\n                .aliasNamePrefixingEnabled\n                ? alias.name + \"\\\\.\"\n                : \"\";\n            const replacementAliasNamePrefix = this.expressionMap\n                .aliasNamePrefixingEnabled\n                ? this.escape(alias.name) + \".\"\n                : \"\";\n            alias.metadata.columns.forEach(column => {\n                const expression =\n                    \"([ =(]|^.{0})\" +\n                    replaceAliasNamePrefix +\n                    column.propertyPath +\n                    \"([ =),]|.{0}$)\";\n                statement = statement.replace(\n                    new RegExp(expression, \"gm\"),\n                    \"$1\" +\n                        replacementAliasNamePrefix +\n                        this.escape(column.databaseName) +\n                        \"$2\"\n                );\n                const expression2 =\n                    \"([ =(]|^.{0})\" +\n                    replaceAliasNamePrefix +\n                    column.propertyName +\n                    \"([ =),]|.{0}$)\";\n                statement = statement.replace(\n                    new RegExp(expression2, \"gm\"),\n                    \"$1\" +\n                        replacementAliasNamePrefix +\n                        this.escape(column.databaseName) +\n                        \"$2\"\n                );\n            });\n            alias.metadata.relations.forEach(relation => {\n                [\n                    ...relation.joinColumns,\n                    ...relation.inverseJoinColumns\n                ].forEach(joinColumn => {\n                    const expression =\n                        \"([ =(]|^.{0})\" +\n                        replaceAliasNamePrefix +\n                        relation.propertyPath +\n                        \"\\\\.\" +\n                        joinColumn.referencedColumn!.propertyPath +\n                        \"([ =),]|.{0}$)\";\n                    statement = statement.replace(\n                        new RegExp(expression, \"gm\"),\n                        \"$1\" +\n                            replacementAliasNamePrefix +\n                            this.escape(joinColumn.databaseName) +\n                            \"$2\"\n                    ); // todo: fix relation.joinColumns[0], what if multiple columns\n                });\n                if (relation.joinColumns.length > 0) {\n                    const expression =\n                        \"([ =(]|^.{0})\" +\n                        replaceAliasNamePrefix +\n                        relation.propertyPath +\n                        \"([ =),]|.{0}$)\";\n                    statement = statement.replace(\n                        new RegExp(expression, \"gm\"),\n                        \"$1\" +\n                            replacementAliasNamePrefix +\n                            this.escape(relation.joinColumns[0].databaseName) +\n                            \"$2\"\n                    ); // todo: fix relation.joinColumns[0], what if multiple columns\n                }\n            });\n        });\n        return statement;\n    }\n\n    /**\n     * Creates \"WHERE\" expression.\n     */\n    protected createWhereExpression() {\n        const conditions = this.createWhereExpressionString();\n\n        if (this.expressionMap.mainAlias!.hasMetadata) {\n            const metadata = this.expressionMap.mainAlias!.metadata;\n            if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {\n                const column = this.expressionMap.aliasNamePrefixingEnabled\n                    ? this.expressionMap.mainAlias!.name +\n                      \".\" +\n                      metadata.discriminatorColumn.databaseName\n                    : metadata.discriminatorColumn.databaseName;\n\n                console.log(\"with a discriminator\");\n\n                const condition = `${this.replacePropertyNames(\n                    column\n                )} IN (:...discriminatorColumnValues)`;\n                return ` WHERE ${\n                    conditions.length ? \"(\" + conditions + \") AND\" : \"\"\n                } ${condition}`;\n            }\n        }\n\n        if (!conditions.length)\n            // TODO copy in to discriminator condition\n            return this.expressionMap.extraAppendedAndWhereCondition\n                ? \" WHERE \" +\n                      this.replacePropertyNames(\n                          this.expressionMap.extraAppendedAndWhereCondition\n                      )\n                : \"\";\n\n        if (this.expressionMap.extraAppendedAndWhereCondition)\n            return (\n                \" WHERE (\" +\n                conditions +\n                \") AND \" +\n                this.replacePropertyNames(\n                    this.expressionMap.extraAppendedAndWhereCondition\n                )\n            );\n\n        return \" WHERE \" + conditions;\n    }\n\n    /**\n     * Creates \"RETURNING\" / \"OUTPUT\" expression.\n     */\n    protected createReturningExpression(): string {\n        const columns = this.getReturningColumns();\n        const driver = this.connection.driver;\n\n        // also add columns we must auto-return to perform entity updation\n        // if user gave his own returning\n        if (\n            typeof this.expressionMap.returning !== \"string\" &&\n            this.expressionMap.extraReturningColumns.length > 0 &&\n            driver.isReturningSqlSupported()\n        ) {\n            columns.push(\n                ...this.expressionMap.extraReturningColumns.filter(column => {\n                    return columns.indexOf(column) === -1;\n                })\n            );\n        }\n\n        if (columns.length) {\n            let columnsExpression = columns\n                .map(column => {\n                    const name = this.escape(column.databaseName);\n                    if (driver instanceof SqlServerDriver) {\n                        if (\n                            this.expressionMap.queryType === \"insert\" ||\n                            this.expressionMap.queryType === \"update\"\n                        ) {\n                            return \"INSERTED.\" + name;\n                        } else {\n                            return (\n                                this.escape(this.getMainTableName()) +\n                                \".\" +\n                                name\n                            );\n                        }\n                    } else {\n                        return name;\n                    }\n                })\n                .join(\", \");\n\n            if (driver instanceof OracleDriver) {\n                columnsExpression +=\n                    \" INTO \" +\n                    columns\n                        .map(column => {\n                            // Hack Julien (Fix the parameter too long issue we have on oracle (limit is 30)\n                            // const parameterName = \"output_\" + column.databaseName;\n                            const parameterName = DriverUtils.buildColumnAlias(\n                                this.connection.driver,\n                                \"output\",\n                                column.databaseName\n                            );\n                            this.expressionMap.nativeParameters[\n                                parameterName\n                            ] = {\n                                type: driver.columnTypeToNativeParameter(\n                                    column.type\n                                ),\n                                dir: driver.oracle.BIND_OUT\n                            };\n                            return this.connection.driver.createParameter(\n                                parameterName,\n                                Object.keys(this.expressionMap.nativeParameters)\n                                    .length\n                            );\n                        })\n                        .join(\", \");\n            }\n            return columnsExpression;\n        } else if (typeof this.expressionMap.returning === \"string\") {\n            return this.expressionMap.returning;\n        }\n\n        return \"\";\n    }\n\n    /**\n     * If returning / output cause is set to array of column names,\n     * then this method will return all column metadatas of those column names.\n     */\n    protected getReturningColumns(): ColumnMetadata[] {\n        const columns: ColumnMetadata[] = [];\n        if (Array.isArray(this.expressionMap.returning)) {\n            (this.expressionMap.returning as string[]).forEach(columnName => {\n                if (this.expressionMap.mainAlias!.hasMetadata) {\n                    columns.push(\n                        ...this.expressionMap.mainAlias!.metadata.findColumnsWithPropertyPath(\n                            columnName\n                        )\n                    );\n                }\n            });\n        }\n        return columns;\n    }\n\n    /**\n     * Concatenates all added where expressions into one string.\n     */\n    protected createWhereExpressionString(): string {\n        return this.expressionMap.wheres\n            .map((where, index) => {\n                switch (where.type) {\n                    case \"and\":\n                        return (\n                            (index > 0 ? \"AND \" : \"\") +\n                            this.replacePropertyNames(where.condition)\n                        );\n                    case \"or\":\n                        return (\n                            (index > 0 ? \"OR \" : \"\") +\n                            this.replacePropertyNames(where.condition)\n                        );\n                    default:\n                        return this.replacePropertyNames(where.condition);\n                }\n            })\n            .join(\" \");\n    }\n\n    /**\n     * Creates \"WHERE\" expression and variables for the given \"ids\".\n     */\n    protected createWhereIdsExpression(ids: any | any[]): string {\n        const metadata = this.expressionMap.mainAlias!.metadata;\n        const normalized = (Array.isArray(ids) ? ids : [ids]).map(id =>\n            metadata.ensureEntityIdMap(id)\n        );\n\n        // using in(...ids) for single primary key entities\n        if (\n            !metadata.hasMultiplePrimaryKeys &&\n            metadata.embeddeds.length === 0\n        ) {\n            const primaryColumn = metadata.primaryColumns[0];\n\n            // getEntityValue will try to transform `In`, it is a bug\n            // todo: remove this transformer check after #2390 is fixed\n            if (!primaryColumn.transformer) {\n                return this.computeWhereParameter({\n                    [primaryColumn.propertyName]: In(\n                        normalized.map(id =>\n                            primaryColumn.getEntityValue(id, false)\n                        )\n                    )\n                });\n            }\n        }\n\n        // create shortcuts for better readability\n        const alias = this.expressionMap.aliasNamePrefixingEnabled\n            ? this.escape(this.expressionMap.mainAlias!.name) + \".\"\n            : \"\";\n        let parameterIndex = Object.keys(this.expressionMap.nativeParameters)\n            .length;\n\n        if (metadata.primaryColumns.length > 1) {\n            const whereStrings = normalized.map((id, index) => {\n                const whereSubStrings: string[] = [];\n                metadata.primaryColumns.forEach(\n                    (primaryColumn, secondIndex) => {\n                        const parameterName = \"id_\" + index + \"_\" + secondIndex;\n                        // whereSubStrings.push(alias + this.escape(primaryColumn.databaseName) + \"=:id_\" + index + \"_\" + secondIndex);\n                        whereSubStrings.push(\n                            alias +\n                                this.escape(primaryColumn.databaseName) +\n                                \" = \" +\n                                this.connection.driver.createParameter(\n                                    parameterName,\n                                    parameterIndex\n                                )\n                        );\n                        this.expressionMap.nativeParameters[\n                            parameterName\n                        ] = primaryColumn.getEntityValue(id, true);\n                        parameterIndex++;\n                    }\n                );\n                return whereSubStrings.join(\" AND \");\n            });\n            return whereStrings.length > 1\n                ? \"(\" +\n                      whereStrings\n                          .map(whereString => \"(\" + whereString + \")\")\n                          .join(\" OR \") +\n                      \")\"\n                : whereStrings[0];\n        } else {\n            const [primaryColumn] = metadata.primaryColumns;\n            const normalizedValues = normalized.map(\n                ent => ent[Object.keys(ent)[0]]\n            );\n            const areAllNumbers = normalizedValues.every(\n                (id: any) => typeof id === \"number\"\n            );\n            let paramAndValues;\n            if (areAllNumbers) {\n                paramAndValues = DriverUtils.buildParamAndValuesForInClause(\n                    this.connection.driver,\n                    `${alias + this.escape(primaryColumn.databaseName)}`,\n                    normalizedValues\n                );\n                return `${\n                    paramAndValues.param\n                } IN (${paramAndValues.values.join(\", \")})`;\n            } else {\n                paramAndValues = DriverUtils.buildParamAndValuesForInClause(\n                    this.connection.driver,\n                    `${alias + this.escape(primaryColumn.databaseName)}`,\n                    normalized.map(val =>\n                        primaryColumn.getEntityValue(val, true)\n                    )\n                );\n                this.expressionMap.parameters[\"qb_ids\"] = paramAndValues.values;\n                return `${paramAndValues.param} IN (:...qb_ids)`;\n            }\n        }\n    }\n\n    /**\n     * Computes given where argument - transforms to a where string all forms it can take.\n     */\n    protected computeWhereParameter(\n        where:\n            | string\n            | ((qb: this) => string)\n            | Brackets\n            | ObjectLiteral\n            | ObjectLiteral[]\n    ) {\n        if (typeof where === \"string\") return where;\n\n        if (where instanceof Brackets) {\n            const whereQueryBuilder = this.createQueryBuilder();\n            where.whereFactory(whereQueryBuilder as any);\n            const whereString = whereQueryBuilder.createWhereExpressionString();\n            this.setParameters(whereQueryBuilder.getParameters());\n            return whereString ? \"(\" + whereString + \")\" : \"\";\n        } else if (where instanceof Function) {\n            return where(this);\n        } else if (where instanceof Object) {\n            const wheres: ObjectLiteral[] = Array.isArray(where)\n                ? where\n                : [where];\n            let andConditions: string[];\n            let parameterIndex = Object.keys(\n                this.expressionMap.nativeParameters\n            ).length;\n\n            if (this.expressionMap.mainAlias!.hasMetadata) {\n                andConditions = wheres.map((where, whereIndex) => {\n                    const propertyPaths = EntityMetadata.createPropertyPath(\n                        this.expressionMap.mainAlias!.metadata,\n                        where\n                    );\n\n                    return propertyPaths\n                        .map((propertyPath, propertyIndex) => {\n                            const columns = this.expressionMap.mainAlias!.metadata.findColumnsWithPropertyPath(\n                                propertyPath\n                            );\n                            return columns\n                                .map((column, columnIndex) => {\n                                    const aliasPath = this.expressionMap\n                                        .aliasNamePrefixingEnabled\n                                        ? `${this.alias}.${propertyPath}`\n                                        : column.propertyPath;\n                                    let parameterValue = column.getEntityValue(\n                                        where,\n                                        true\n                                    );\n                                    if (parameterValue === undefined) return;\n                                    const parameterName =\n                                        \"where_\" +\n                                        whereIndex +\n                                        \"_\" +\n                                        propertyIndex +\n                                        \"_\" +\n                                        columnIndex;\n                                    const parameterBaseCount = Object.keys(\n                                        this.expressionMap.nativeParameters\n                                    ).filter(x => x.startsWith(parameterName))\n                                        .length;\n\n                                    if (parameterValue === null) {\n                                        return `${aliasPath} IS NULL`;\n                                    } else if (\n                                        parameterValue instanceof FindOperator\n                                    ) {\n                                        let parameters: any[] = [];\n                                        if (parameterValue.useParameter) {\n                                            const realParameterValues: any[] = parameterValue.multipleParameters\n                                                ? parameterValue.value\n                                                : [parameterValue.value];\n                                            realParameterValues.forEach(\n                                                (\n                                                    realParameterValue,\n                                                    realParameterValueIndex\n                                                ) => {\n                                                    // don't create parameters for number to prevent max number of variables issues as much as possible\n                                                    if (\n                                                        typeof realParameterValue ===\n                                                        \"number\"\n                                                    ) {\n                                                        parameters.push(\n                                                            realParameterValue\n                                                        );\n                                                    } else {\n                                                        this.expressionMap.nativeParameters[\n                                                            parameterName +\n                                                                (parameterBaseCount +\n                                                                    realParameterValueIndex)\n                                                        ] = realParameterValue;\n                                                        parameterIndex++;\n                                                        parameters.push(\n                                                            this.connection.driver.createParameter(\n                                                                parameterName +\n                                                                    (parameterBaseCount +\n                                                                        realParameterValueIndex),\n                                                                parameterIndex -\n                                                                    1\n                                                            )\n                                                        );\n                                                    }\n                                                }\n                                            );\n                                        }\n                                        return parameterValue.toSql(\n                                            this.connection,\n                                            aliasPath,\n                                            parameters\n                                        );\n                                    } else {\n                                        this.expressionMap.nativeParameters[\n                                            parameterName\n                                        ] = parameterValue;\n                                        parameterIndex++;\n                                        const parameter = this.connection.driver.createParameter(\n                                            parameterName,\n                                            parameterIndex - 1\n                                        );\n                                        return `${aliasPath} = ${parameter}`;\n                                    }\n                                })\n                                .filter(expression => !!expression)\n                                .join(\" AND \");\n                        })\n                        .filter(expression => !!expression)\n                        .join(\" AND \");\n                });\n            } else {\n                andConditions = wheres.map((where, whereIndex) => {\n                    return Object.keys(where)\n                        .map((key, parameterIndex) => {\n                            const parameterValue = where[key];\n                            const aliasPath = this.expressionMap\n                                .aliasNamePrefixingEnabled\n                                ? `${this.alias}.${key}`\n                                : key;\n                            if (parameterValue === null) {\n                                return `${aliasPath} IS NULL`;\n                            } else {\n                                const parameterName =\n                                    \"where_\" +\n                                    whereIndex +\n                                    \"_\" +\n                                    parameterIndex;\n                                this.expressionMap.nativeParameters[\n                                    parameterName\n                                ] = parameterValue;\n                                parameterIndex++;\n                                return `${aliasPath} = ${this.connection.driver.createParameter(\n                                    parameterName,\n                                    parameterIndex - 1\n                                )}`;\n                            }\n                        })\n                        .join(\" AND \");\n                });\n            }\n\n            if (andConditions.length > 1)\n                return andConditions\n                    .map(where => \"(\" + where + \")\")\n                    .join(\" OR \");\n\n            return andConditions.join(\"\");\n        }\n\n        return \"\";\n    }\n\n    /**\n     * Creates a query builder used to execute sql queries inside this query builder.\n     */\n    protected obtainQueryRunner() {\n        return this.queryRunner || this.connection.createQueryRunner(\"master\");\n    }\n}\n"],"sourceRoot":".."}